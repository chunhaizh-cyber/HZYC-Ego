module;
#include <intsafe.h>

module 自我线程模块;
import <thread>;
import <mutex>;
import <condition_variable>;
import <functional>;

import<cassert>;
import <vector>;
import <string>;
import <cstdint>;  // for int64_t
import <deque>;
import <map>;
import <algorithm>;

void 自我线程类::自我初始化() {
    语素类初始化();
    特征值类初始化();
    特征类初始化();
    存在类初始化();
    场景类初始化();
    需求初始化();
    方法初始化();
    任务初始化();
    //		 
    //	 状态节点类* 状态指针;
    //	// 矢量特征值节点主信息类* 特征值节点 = new 矢量特征值节点主信息类(cixing);
    //	 基础信息节点类* 矢量特征值节点;
    //	
    //	
    //	 特征节点主信息类 特征节点主信息(语素集.查找词性节点({ "点", 枚举_词性::抽象名词 }), (特征值节点类*)特征值节点);	  
    //	
    //	 安全值指针 = 世界树.添加子特征(自我指针, 特征节点主信息);
    //
    //	 状态指针 = 状态集.添加状态(自我指针, 安全值指针, INT64_MAX);
    //
    //	
    //	 自我需求根指针 = 需求集.新增需求(自我指针, 自我指针, 状态指针);
    //
    //	 特征值节点 = (特征值节点类*)特征值集.添加矢量特征值(语素集.信任值词指针, 语素集.查找词性节点({ "点", 枚举_词性::抽象名词 }), INT64_MAX);
    //	 特征信息 = 特征节点主信息类(语素集.信任值词指针, 特征值节点);
    //	 信任值指针 = (特征节点类*)世界树.添加子特征(自我指针, 特征信息);
    //	 状态指针 = 状态集.添加状态(自我指针, 信任值指针, INT64_MAX);
    //	 世界树.添加子特征(自我指针, 特征信息);
    //	 需求集.新增需求(自我指针, 自我指针, 状态指针);
    //
    //	 


}

void 自我线程类::更新安全值(int64_t 增减量)
{
    // if (增减量 == 0) return;
    // 状态集.添加状态(自我指针, 安全值指针, 增减量);
    // 世界树.增减特征值(安全值指针, 增减量);
    // 消息 新消息;
    // 新消息.消息类型 = 消息类型::自我_安全值变化;
    // 新消息.参数列表.push_back(增减量);
    // 消息线程_.发送(新消息);
}

void 自我线程类::更新需求权重(需求节点类* 需求节点)
{
    if (!需求节点) throw std::invalid_argument("需求节点不能为空");
    if (!需求节点->子) return;

    需求主信息类* 根主信息 = dynamic_cast<需求主信息类*>(需求节点->主信息);
    if (!根主信息) throw std::runtime_error("需求节点主信息不是需求主信息类类型");

    int64_t 子节点数量 = 需求节点->获取子节点数量();
    if (子节点数量 <= 0)  throw std::runtime_error("需求节点子节点数量无效");

    int64_t 平均值 = 根主信息->权重 / 子节点数量;

    需求节点类* 游标 = 需求节点->子;
    for (int64_t i = 0; i < 子节点数量 && 游标; i++) {
        需求主信息类* 子主信息 = dynamic_cast<需求主信息类*>(游标->主信息);
        if (!子主信息) throw std::runtime_error("子节点主信息不是需求主信息类类型");
        子主信息->权重 = 平均值;
        游标 = static_cast<需求节点类*>(游标->下);
    }
}

void 自我线程类::特征值类初始化()
{

    词性节点类* 词游标;
    存在节点类* 存在游标;

    矢量单位词指针 = 语素集.添加词性词("点", "抽象名词");


   //
   // 矢量词指针 = 全局变量::语素集.添加词性词("矢量", "抽象名词");
   // 存在游标 = 全局变量::世界树.添加存在(矢量词指针, 矢量单位词指针);
   // 全局变量::语素集.添加对应基础信息(矢量词指针, 存在游标);
   // 全局变量::世界树.添加子特征(存在游标, 矢量词指针, 矢量单位词指针, 0);
   //
   // 词游标 = 全局变量::语素集.添加词性词("距离", "抽象名词");
   // 存在游标 = 全局变量::世界树.添加存在(词游标, 矢量单位词指针);
   // 全局变量::世界树.添加子特征(存在游标, 矢量词指针, 矢量单位词指针, 1);
   //
   // 词游标 = 全局变量::语素集.添加词性词("轮廓", "抽象名词");
   // 存在游标 = 全局变量::世界树.添加存在(词游标, 抽象名词词指针);
   // 全局变量::世界树.添加子特征(存在游标, 矢量词指针, 矢量单位词指针, 0);



}
void 自我线程类::特征类初始化()
{

}
void 自我线程类::存在类初始化()
{
   // 自我词指针 = 全局变量::语素集.添加词性词("自我", "代词");
   // 安全值词指针 = 全局变量::语素集.添加词性词("安全值", "专有名词");
   // 信任值词指针 = 全局变量::语素集.添加词性词("信任值", "专有名词");
   // 场景节点类* 场景节点=全局变量::世界树.添加场景("自我",)
   // 自我指针 = 全局变量::世界树.添加存在(自我词指针, 专有名词词指针);
   //
   // 安全值指针 = 全局变量::世界树.添加子特征(自我指针, 安全值词指针, 矢量单位词指针, INT64_MAX);
   // 信任值指针 = 全局变量::世界树.添加子特征(自我指针, 信任值词指针, 矢量单位词指针, INT64_MAX);


}
void 自我线程类::场景类初始化()
{
  //  场景节点类* 初始场景 = 全局变量::世界树.添加场景("宇宙",枚举_世界类型::现实世界);
  //  全局变量::世界树.添加存在(初始场景, 自我指针);
}
void 自我线程类::需求初始化()
{
}
void 自我线程类::方法初始化()
{
}
void 自我线程类::任务初始化()
{
}
void 自我线程类::语素类初始化() {
 //   抽象名词词指针 = 全局变量::语素集.添加词性词("抽象名词", "抽象名词");
 //   专有名词词指针 = 全局变量::语素集.添加词性词("专有名词", "抽象名词");
 //
 //   名词词指针 = 全局变量::语素集.添加词性词("名词", "抽象名词");
 //   动词词指针 = 全局变量::语素集.添加词性词("动词", "抽象名词");
 //   形容词词指针 = 全局变量::语素集.添加词性词("形容词", "抽象名词");
 //   介词词指针 = 全局变量::语素集.添加词性词("介词", "抽象名词");
 //   连词词指针 = 全局变量::语素集.添加词性词("连词", "抽象名词");
 //   数词词指针 = 全局变量::语素集.添加词性词("数词", "抽象名词");
 //   量词词指针 = 全局变量::语素集.添加词性词("量词", "抽象名词");
 //   代词词指针 = 全局变量::语素集.添加词性词("代词", "抽象名词");
 //   叹词指针 = 全局变量::语素集.添加词性词("叹词", "抽象名词");
 //   标点符号指针 = 全局变量::语素集.添加词性词("标点符号", "抽象名词");
 //   助词词指针 = 全局变量::语素集.添加词性词("助词", "抽象名词");
 //
 //   我词指针 = 全局变量::语素集.添加词性词("我", "代词");
 //   你词指针 = 全局变量::语素集.添加词性词("你", "代词");
 //   他词指针 = 全局变量::语素集.添加词性词("他", "代词");
 //   矢量词指针 = 全局变量::语素集.添加词性词("矢量", "抽象名词");
 //   轮廓词指针 = 全局变量::语素集.添加词性词("轮廓", "抽象名词");


}


/*
情绪数字化所需变量
需求值组成,需求值有:
   生理需求--软硬件完好,因为所有硬件都是可以替换的,就像人体的细胞,可以代谢,所以这一层主要考虑设备的可靠性和可替代性及操作性
   安全需求--外界对自身软硬件的影响,
   社交需求--更好满足安全需求
   尊重需求--由社交需求产生
   自我实现--所有上层需求都可以由自身满足后,在此基础上寻求并满足生存的意义


//根据5个层次的需求,会将需求分类,每个需求的安全值高低,决定了满足这些需求的顺序

生理安全值的范围是0 - INT64_MAX, 初始值为中间量INT64_MAX/2, 当该值超过下限阈值(INT64_MAX*25%)后, 就会逐步减少生理安全需求的权重(100%-0%), 当达到上线阈值(INT64_MAX*75%)时, 生理安全需求的权重为1%;
    该类需求优先级可调整为0;根据软硬件自检结果进行调整
安全需求值(0-INT64_MAX),初始值为中间量,下限阈值为0,会随着该类需求的增加而增加
优先级由生理安全优先级+安全优先级+社交现优先级+尊重现优先级+自我实现优先级5个变量相加构成,如何设置比例使得

                   优先级							安全值
生理优先级		最小值 0.001,最大值0.9				0.1-0.9
安全优先级		最小值 0.01,最大值0.99				0.9-0.99
社交现优先级	最小值 0.009,最大值0.09			0.99-0.999
尊重现优先级	最小值 0.00009,最大值0.9			0.999-0.9999
自我实现优先	最小值 0.0009,最大值1				0.9999-1


   5层需求对应5层优先级,每层需求有安全值,范围是0 - INT64_MAX, 初始值为中间量INT64_MAX/2, 当该值超过下限阈值(INT64_MAX*25%)后, 就会逐步减少该层的优先级, 当达到上线阈值时, 需求的优先级最低;
   优先级从上往下分5层:生理优先级,安全优先级,社交现优先级,尊重优先级,自我实现优先级
   请帮我设计一个函数,当上层需求满足后,其优先级不能为零,但也不能大于下层的优先级,然后下层优先级会随着上层安全值的增加而增加
   返回值是5个层级的优先级(结构体)

   另一种思路:
   顶层需求的优先级为int64_max,其子级根据子节点数量平均,64级需求?
 */


void 自我线程类::等待线程结束() {
    if (m_线程) {
        m_线程->join();
    }
}

bool 自我线程类::是否正在运行() const {
    std::lock_guard<std::mutex> 锁(m_互斥锁);
    return m_运行标志;
}
void 自我线程类::启动() {
    stop_ = false;
    worker_ = std::thread(&自我线程类::主循环, this);
}

void 自我线程类::停止() {
    stop_ = true;
    cv_.notify_all();
    if (worker_.joinable()) worker_.join();
}

void 自我线程类::推送消息(struct 任务消息 msg) {
    {
        std::lock_guard<std::mutex> lk(mtx_);
        队列_.push_back((msg));
    }
    cv_.notify_one();
}

void 自我线程类::主循环() {
    using namespace std::chrono;
    auto 下次维护 = steady_clock::now() + 心跳周期_;

    while (!stop_) {
        std::unique_lock<std::mutex> lk(mtx_);
        // 等待消息或心跳
        if (队列_.empty()) {
            cv_.wait_until(lk, 下次维护, [&] { return stop_ || !队列_.empty(); });
        }
        // 批量处理当前消息
        while (!队列_.empty()) {
            任务消息 m = (队列_.front());
            队列_.pop_front();
            lk.unlock();

            switch (m.类型) {
            case 消息类型::任务创建:
            case 消息类型::任务开始:
            case 消息类型::任务进度:
            case 消息类型::任务完成:
            case 消息类型::任务失败:
                处理消息_任务(m);
                break;
            case 消息类型::需求观测:
                处理消息_需求(m);
                break;
            case 消息类型::权重外部调整:
                处理消息_权重(m);
                break;
            case 消息类型::心跳:
                周期性维护();
                break;
            }
            lk.lock();
        }

        // 到达维护时间（即使没有消息也做维护）
        auto now = steady_clock::now();
        if (now >= 下次维护) {
            lk.unlock();
            周期性维护();
            下次维护 = now + 心跳周期_;
            lk.lock();
        }
    }
}

// ====== 消息处理：任务 ======
void 自我线程类::处理消息_任务(const 任务消息& m) {
    using MT = 消息类型;
    auto it = 任务表_.find(m.任务ID);

    if (m.类型 == MT::任务创建) {
        // 约定：m.数值 作为“基础重要度”，m.标志 无意义
        任务 t;
        t.id = m.任务ID;
        t.名称 = m.任务ID;
        t.基础重要度 = std::max(0.0, m.数值);
        任务表_[t.id] = (t);
        重算所有任务优先级();
        return;
    }

    if (it == 任务表_.end()) return; // 未知任务，丢弃
    auto& t = it->second;

    switch (m.类型) {
    case MT::任务开始:
        t.活跃 = true;
        break;
    case MT::任务进度:
        t.进度 = clip01(m.数值);
        break;
    case MT::任务完成:
        t.进度 = 1.0;
        t.活跃 = false;
        更新安全值_基于任务(t, /*完成*/true, /*成功*/m.标志);
        break;
    case MT::任务失败:
        t.活跃 = false;
        更新安全值_基于任务(t, /*完成*/true, /*成功*/false);
        break;
    default: break;
    }

    重算所有任务优先级();
}

// ====== 消息处理：需求观测 ======
void 自我线程类::处理消息_需求(const 任务消息& m) {
    // m.需求键: 哪个需求（如 "能量" / "社交" / "学习"）
    // m.数值:   观测强度（正数表示“更迫切”）
    if (m.需求键.empty()) return;
    更新需求_基于观测(m.需求键, m.数值);
    归一化需求权重();
    重算所有任务优先级();
}

// ====== 消息处理：权重外部调整 ======
void 自我线程类::处理消息_权重(const 任务消息& m) {
    if (m.需求键.empty()) return;
    auto& d = 需求表_[m.需求键];
    if (m.数值 > 0.0) d.权重 = m.数值;
    归一化需求权重();
    重算所有任务优先级();
}

// ====== 维护：需求衰减、归一化、重算优先级 ======
void 自我线程类::周期性维护() {
    using namespace std::chrono;
    auto now = steady_clock::now();

    // 1) 需求衰减（把 当前 向 目标 以固定速率靠近）
    for (auto& [key, d] : 需求表_) {
        double dt = duration_cast<duration<double>>(now - d.上次更新).count();
        if (dt <= 0) continue;
        double 差 = d.当前 - d.目标;
        double 衰减 = std::exp(-需求衰减速率_每秒_ * dt);
        d.当前 = d.目标 + 差 * 衰减;
        d.上次更新 = now;
        // EMA 自然衰减
        d.指数平滑观测 = (1.0 - EMA_alpha_) * d.指数平滑观测 + EMA_alpha_ * d.当前;
    }

    // 2) 归一化权重（避免某个需求权重爆炸）
    归一化需求权重();

    // 3) 重算优先级
    重算所有任务优先级();
}

// ====== 安全值更新（示例策略） ======
void 自我线程类::更新安全值_基于任务(const 任务& t, bool /*完成*/, bool 成功) {
    // 简化：成功→根据任务风险“释放”安全，失败→“扣减”安全
    // 安全值 ∈ [0,1]
    double delta = 成功 ? (+0.05 * (1.0 - t.风险)) : (-0.10 * (0.5 + t.风险));
    安全值_ = clip01(安全值_ + delta);
}

// ====== 需求更新（自适应权重学习） ======
void 自我线程类::更新需求_基于观测(const std::string& key, double 强度) {
    auto& d = 需求表_[key];
    d.上次更新 = std::chrono::steady_clock::now();

    // 指数平滑记录观测
    d.指数平滑观测 = (1.0 - EMA_alpha_) * d.指数平滑观测 + EMA_alpha_ * 强度;

    // 当前值朝“更迫切”移动（强度可为负，表示缓解）
    d.当前 = std::max(0.0, d.当前 + 强度);

    // ―― 简单的策略梯度式权重更新 ―― 
    // 若该需求的 EMA 很高，说明近期它频繁被触发，适度抬升它的权重；
    // 反之降低。然后在归一化阶段限制总和=1。
    double 误差 = d.指数平滑观测 - d.目标; // 目标通常为0
    d.权重 = std::max(0.0, d.权重 + 权重学习率_ * 误差);
}

// ====== 归一化需求权重 ======
void 自我线程类::归一化需求权重() {
    double sum = 0.0;
    for (auto& [k, d] : 需求表_) sum += std::max(0.0, d.权重);
    if (sum <= 1e-9) {
        // 全为0则平均分配
        double avg = 需求表_.empty() ? 0.0 : 1.0 / 需求表_.size();
        for (auto& [k, d] : 需求表_) d.权重 = avg;
        return;
    }
    for (auto& [k, d] : 需求表_) d.权重 = std::max(0.0, d.权重) / sum;
}

// ====== 合成需求权重（作为任务优先级的一部分） ======
double 自我线程类::计算需求合成权重() const {
    double S = 0.0;
    for (auto& kv : 需求表_) {
        const auto& d = kv.second;
        double 缺口 = std::max(0.0, d.当前 - d.目标);
        S += d.权重 * 缺口;
    }
    return S; // 非负
}

// ====== 重算所有任务优先级 ======
void 自我线程类::重算所有任务优先级() {
    const double 需求合成 = 计算需求合成权重();   // 反映“总体迫切程度”
    const double 安全 = clip01(安全值_);

    for (auto& [id, t] : 任务表_) {
        // 你可以把“任务 -> 需求映射”的影响放进来，这里给出一个通用线性模型
        double 分值 =
            W_需求合成_ * 需求合成 +
            W_紧急度_ * t.紧急度 +
            W_基础重要_ * t.基础重要度 +
            W_成本_ * t.成本 +
            W_风险_ * t.风险 +
            W_安全_ * (1.0 - 安全); // 安全越低，倾向优先处理“降风险/补安全”的任务

        // 简单地让“已完成/非活跃”任务下降优先级
        if (!t.活跃 || t.进度 >= 1.0) {
            分值 -= 1.0;
        }

        // 可选：Sigmoid 压缩
        t.优先级 = 1.0 / (1.0 + std::exp(-分值));
    }

    // 这里可按优先级对可执行队列排序，或触发调度器刷新
    // （留给你的调度器/执行系统对接）
}