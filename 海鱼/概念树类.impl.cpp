module 概念树模块;

import 模板模块;
import 主信息定义模块;
import 语素模块;
import 宇宙链模块;

import <string>;
import <vector>;
import <unordered_map>;
import <set>;
import <iostream>;

// ======================== 实现部分 ========================

概念树类::概念树类() {
    初始化五大根概念();
    std::cout << "【概念树】基于宇宙链表构建完成\n";
}

// 初始化五大根：存在 / 事件 / 关系 / 属性 / 模态
void 概念树类::初始化五大根概念() {
    const std::vector<std::string> 根名 = {
        "存在", "事件", "关系", "属性", "模态"
    };

    节点类* 根节点们[5]{};

    for (size_t i = 0; i < 根名.size(); ++i) {
        // 1. 概念本体（基础信息只有一份）
        基础信息基类* 主信息 = 获取或创建概念主信息(根名[i], "概念根");

        // 2. 在“宇宙链表”上创建一个节点，作为概念树根
        根节点们[i] = 宇宙链.添加节点(主信息);
        抽象层级[根节点们[i]] = 0;
    }

    根_存在 = 根节点们[0];
    根_事件 = 根节点们[1];
    根_关系 = 根节点们[2];
    根_属性 = 根节点们[3];
    根_模态 = 根节点们[4];

    std::cout << "【概念树】五大根概念已植入（第 0 层）\n";
}

// 概念本体：名字 → 主信息（路线 A 核心）
基础信息基类* 概念树类::获取或创建概念主信息(const std::string& 概念名,const std::string& 词性标签
) {
    // 先看有没有
    if (auto it = 概念主信息表.find(概念名); it != 概念主信息表.end()) {
        return it->second;
    }

    // 没有就创建新的“存在主信息”作为概念本体
    auto* 主信息 = new 存在节点主信息类();

    // 按你原来的设计：名称 = 语素集中对应的词性节点
    // 注意：这里假设 语素集.添加词性词 已经改成用 std::string
    词性节点类* 名称词性 = 语素集.添加词性词(概念名, 词性标签);
    主信息->名称 = 名称词性;

    概念主信息表.emplace(概念名, 主信息);
    return 主信息;
}

// 在概念树里挂一个“抽象概念节点”
概念树类::节点类*
概念树类::新建概念节点(
    基础信息基类* 概念主信息,
    节点类* 父概念
) {
    if (!概念主信息) return nullptr;

    if (!父概念) {
        // 没指定父概念，默认挂到“存在”根下面
        父概念 = 根_存在;
    }

    // 统一通过“宇宙链表”创建节点，并设定父子关系
    节点类* 新节点 = 宇宙链.添加子节点(父概念, 概念主信息);

    int 父层 = 0;
    if (auto it = 抽象层级.find(父概念); it != 抽象层级.end()) {
        父层 = it->second;
    }
    抽象层级[新节点] = 父层 + 1;

    return 新节点;
}

// 一步到位：名 → 主信息 → 节点，并触发“向上抽象”
概念树类::节点类*
概念树类::新建并提交概念(
    const std::string& 概念名,
    节点类* 父概念
) {
    基础信息基类* 主信息 = 获取或创建概念主信息(概念名, "抽象概念");

    if (!父概念) {
        父概念 = 根_存在;
    }

    节点类* 新节点 = 新建概念节点(主信息, 父概念);

    std::cout << "概念树 ・ 第 "
        << 取抽象层级(新节点)
        << " 层抽象生成：【" << 概念名 << "】\n";

    // 关键：新加了一个子概念 → 对“父概念”做一次向上抽象尝试
    尝试向上抽象(父概念);

    return 新节点;
}

// 向上抽象：
// 根据“当前层概念”的所有子概念的抽象特征，寻找共同本质 → 生成更高阶概念
void 概念树类::尝试向上抽象(节点类* 当前层概念) {
    if (!当前层概念 || !当前层概念->子) return;

    bool 首次 = true;
    std::set<词性节点类*> 共同本质;

    节点类* 子起点 = 当前层概念->子;
    节点类* 游标 = 子起点;

    do {
        auto 当前特征集 = 获取抽象特征集(游标);
        if (!当前特征集.empty()) {
            if (首次) {
                共同本质 = (当前特征集);
                首次 = false;
            }
            else {
                共同本质 = 交集(共同本质, 当前特征集);
            }

            if (共同本质.empty()) {
                break;  // 没有共同本质，无法再往上抽象
            }
        }

        游标 = 游标->下;
    } while (游标 && 游标 != 子起点);

    if (共同本质.empty()) return;

    // 在当前层之上，生成一个“更高阶抽象”
    生成更高阶抽象(当前层概念, 共同本质);

    // 如有需要，可以继续对更上层父概念尝试（递归的“金字塔收敛”）
    if (当前层概念->父) {
        尝试向上抽象(static_cast<节点类*>(当前层概念->父));
    }
}

// 生成更高阶抽象
void 概念树类::生成更高阶抽象(
    节点类* 当前层概念,
    const std::set<词性节点类*>& 共同本质
) {
    // 名字格式：↑{特征1_特征2_...}
    std::string 新名 = "↑{";
    bool first = true;
    for (auto* f : 共同本质) {
        if (!first) 新名 += "_";
        新名 += 取词面(f);
        first = false;
    }
    新名 += "}";

    // 查重：如果整个宇宙里已经有同名概念，跳过
    if (查找概念(新名)) {
        std::cout << "概念树 ・ 已存在更高阶抽象：" << 新名 << "，跳过\n";
        return;
    }

    // 利用“概念主信息表”保证本体唯一
    基础信息基类* 主信息 = 获取或创建概念主信息(新名, "抽象概念");
    节点类* 新抽象 = 新建概念节点(主信息, 当前层概念);

    std::cout << "概念树 ・ 向上抽象成功：第 "
        << 取抽象层级(当前层概念)
        << " 层 → 第 "
        << 取抽象层级(新抽象)
        << " 层：【" << 新名 << "】\n";

    // TODO：如果你愿意，可以在这里把“共同本质”作为特征节点挂到 新抽象 的子链上
}

// 抽象特征集：从“抽象节点”的子链中提取所有“特征类型”
std::set<词性节点类*>
概念树类::获取抽象特征集(节点类* 抽象节点) {
    std::set<词性节点类*> 集;
    if (!抽象节点 || !抽象节点->子) return 集;

    节点类* 子起点 = 抽象节点->子;
    节点类* 游标 = 子起点;

    do {
        if (auto* 特征主 =
            dynamic_cast<特征节点主信息类*>(游标->主信息)) {
            if (特征主->类型) {
                集.insert(特征主->类型);
            }
        }
        游标 = 游标->下;
    } while (游标 && 游标 != 子起点);

    return 集;
}

// 简单 set 交集（用指针比较顺序即可）
std::set<词性节点类*>
概念树类::交集(
    const std::set<词性节点类*>& a,
    const std::set<词性节点类*>& b
) {
    std::set<词性节点类*> result;
    auto it1 = a.begin();
    auto it2 = b.begin();

    while (it1 != a.end() && it2 != b.end()) {
        if (*it1 < *it2) {
            ++it1;
        }
        else if (*it2 < *it1) {
            ++it2;
        }
        else {
            result.insert(*it1);
            ++it1;
            ++it2;
        }
    }
    return result;
}

// 在整个“宇宙链表”中按名字查找概念节点
概念树类::节点类*
概念树类::查找概念(const std::string& 名称) {
    auto* 根 = 宇宙链.根指针;
    if (!根) return nullptr;

    节点类* 游标 = 根->链下;
    while (游标 && 游标 != 根) {
        if (auto* 存在主 =
            dynamic_cast<存在节点主信息类*>(游标->主信息)) {

            词性节点类* 名节点 = 存在主->名称;
            if (名节点 && 取词面(名节点) == 名称) {
                return 游标;
            }
        }
        游标 = 游标->链下;
    }
    return nullptr;
}

// 工具：从 词性节点 拿到词面（现在用 std::string）
std::string 概念树类::取词面(词性节点类* 节点) {
    if (!节点 || !节点->父) return {};

    auto* 词主 = dynamic_cast<词主信息类*>(节点->父->主信息);
    if (!词主) return {};

    return 词主->词;  // 注意：这里假定 词主信息类::词 已经改为 std::string
}
