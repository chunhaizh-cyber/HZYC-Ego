export module 特征概念树模块;

import <vector>;
import <unordered_map>;
import <string>;
import <limits>;
import <cmath>;
import <algorithm>;

import 模板模块;
import 主信息定义模块;
import 宇宙链模块;

using std::vector;
using std::unordered_map;
using std::string;

//==============================
//  范围概念信息：专门给“标量特征值”用
//==============================

export struct 范围概念信息 {
    特征节点类* 概念节点 = nullptr;    // 中间概念节点（挂在 类型节点 下面）
    double       最小值 = 0.0;
    double       最大值 = 0.0;
    vector<特征节点类*> 成员叶子;      // 属于该范围的样本特征节点
};

// 将来如果要对矢量做“相似簇概念”，可以仿照 范围概念信息 再建一个：

export struct 相似簇概念信息 {
    特征节点类* 概念节点 = nullptr;
    vector<特征节点类*> 成员叶子;
    // 可以加：代表向量、平均向量、簇的统计信息等
};


//==============================
//  每一个“特征类型”在概念树中的索引记录
//==============================

export struct 特征类型概念记录 {
    词性节点类* 特征类型词 = nullptr;   // 比如 "身高"、"颜色"
    特征节点类* 类型节点 = nullptr;   // 根链上的“无值类型节点”

    vector<特征节点类*>   样本节点列表;   // 所有样本特征节点（一个节点一个值）
    vector<范围概念信息>  范围概念列表;   // 标量值 -> 区间概念
    vector<相似簇概念信息> 相似簇列表;    // 矢量值 -> 相似簇概念（先留接口）
};


//==============================
//  特征概念树类
//==============================

export class 特征概念树类 {
private:
    特征节点类* 根_特征概念 = nullptr;

    // key: 特征类型词->主键
    unordered_map<string, 特征类型概念记录> 类型表;

public:
    特征概念树类() = default;

    void 初始化默认特征概念树() {
        根_特征概念 = nullptr;
        类型表.clear();

        auto* 主信息 = new 特征节点主信息类();
        基础信息基类* 基类指针 = 主信息;

        根_特征概念 = static_cast<特征节点类*>(
            宇宙链.添加子节点(宇宙链.根指针, 基类指针)
            );
        根_特征概念->主键 = "特征概念_根";
    }

    特征节点类* 获取根节点() const { return 根_特征概念; }

    const unordered_map<string, 特征类型概念记录>& 获取类型表() const {
        return 类型表;
    }

    //========================================
    // 1) 获取 / 创建 某个特征类型的“类型节点”
    //    根链上的无值节点：只存“这个特征维度存在”
    //========================================
    特征节点类* 获取或创建类型节点(词性节点类* 特征类型词) {
        if (!特征类型词) return nullptr;
        if (!根_特征概念) {
            初始化默认特征概念树();
        }

        const string& key = 特征类型词->主键;
        auto it = 类型表.find(key);
        if (it != 类型表.end()) {
            return it->second.类型节点;
        }

        auto* 主信息 = new 特征节点主信息类(
            /*名*/ nullptr,
            /*型*/ 特征类型词,
            /*值*/ nullptr
        );
        基础信息基类* 基类指针 = 主信息;

        auto* 类型节点 = static_cast<特征节点类*>(
            宇宙链.添加子节点(根_特征概念, 基类指针)
            );

        特征类型概念记录 记录;
        记录.特征类型词 = 特征类型词;
        记录.类型节点 = 类型节点;

        类型表.emplace(key, (记录));
        return 类型节点;
    }

    //========================================
    // 2) 在某个特征类型下面登记一个“样本特征节点”
    //
    // 说明：
    //    - 这里的 样本特征节点 已经存在于 世界树 中
    //    - 我们只是把它的信息“同步”到特征概念树的索引结构中
    //
    // 使用习惯：
    //    - 当世界树中新增一个特征节点时，调用本函数
    //========================================
    void 登记特征样本(特征节点类* 特征节点) {
        if (!特征节点 || !特征节点->主信息) return;

        auto* 主信息 = dynamic_cast<特征节点主信息类*>(特征节点->主信息);
        if (!主信息 || !主信息->类型 || !主信息->值) return;

        auto* 特征类型词 = 主信息->类型;
        auto* 特征值节点 = static_cast<特征值节点类*>(主信息->值);
        if (!特征值节点 || !特征值节点->主信息) return;

        auto* 值主信息 = dynamic_cast<特征值基类*>(特征值节点->主信息);
        if (!值主信息) return;

        auto* 类型节点 = 获取或创建类型节点(特征类型词);
        if (!类型节点) return;

        // 在索引记录中登记
        auto& 记录 = 类型表[特征类型词->主键];
        记录.样本节点列表.push_back(特征节点);

        // 标量特征值：参与区间概念生长
        if (值主信息->比较模式 == 枚举_特征值比较模式::有序标量) {
            自动归纳_标量(记录, 特征节点, 值主信息);
        }
        // 矢量或字符串：将来可以按“相似簇”生长概念
        else {
            自动归纳_相似簇(记录, 特征节点, 值主信息);
        }
    }

private:
    //========================================================
    // 工具：判断某个样本节点是否已经属于某个范围概念
    //========================================================
    static bool 样本属于某个范围(const 特征类型概念记录& 记录,
        特征节点类* 样本节点)
    {
        for (const auto& 范围 : 记录.范围概念列表) {
            for (auto* 成员 : 范围.成员叶子) {
                if (成员 == 样本节点) return true;
            }
        }
        return false;
    }

    //========================================================
    // 工具：把一个节点重新挂接到新的父节点下面
    //========================================================
    static void 重新挂接到新父(
        基础信息节点类* 节点,
        基础信息节点类* 新父)
    {
        if (!节点 || !新父) return;
        if (节点->父 == 新父) return;

        // 1. 从旧父的子环摘除
        auto* 旧父 = 节点->父;
        if (旧父) {
            if (旧父->子 == 节点) {
                if (节点->下 == 节点) {
                    旧父->子 = nullptr;
                }
                else {
                    旧父->子 = 节点->下;
                    节点->上->下 = 节点->下;
                    节点->下->上 = 节点->上;
                }
            }
            else {
                节点->上->下 = 节点->下;
                节点->下->上 = 节点->上;
            }
            旧父->变更子节点数量(-1);
        }

        // 2. 挂接到新父下面
        if (!新父->子) {
            新父->子 = 节点;
            节点->上 = 节点;
            节点->下 = 节点;
            节点->根 = 节点;
            节点->父 = 新父;
        }
        else {
            auto* 首子 = 新父->子;
            节点->上 = 首子->上;
            节点->下 = 首子;
            节点->根 = 首子->根;
            节点->父 = 新父;

            首子->上->下 = 节点;
            首子->上 = 节点;
        }
        新父->变更子节点数量(1);
    }

    //========================================================
    // 标量特征值：中间生长型区间概念
    // 规则：
    //   - 第一个样本：只记
    //   - 第二个样本：两个值生成一个范围概念节点 [min,max]
    //   - 后续样本：
    //       * 优先尝试归入现有范围（扩张量最小）
    //       * 不合适时：找最近的“孤立样本”，和它一起生成新范围概念
    //========================================================
    void 自动归纳_标量(
        特征类型概念记录& 记录,
        特征节点类* 新样本节点,
        特征值基类* 新值主信息)
    {
        if (!新样本节点 || !新值主信息) return;
        auto& 样本列表 = 记录.样本节点列表;
        auto& 范围列表 = 记录.范围概念列表;
        auto* 类型节点 = 记录.类型节点;
        if (!类型节点) return;

        double 新值 = 0.0;
        if (!新值主信息->转为标量(新值)) {
            // 理论上不会走到这里，因为比较模式已经是 有序标量
            return;
        }

        if (样本列表.size() <= 1) {
            // 至少需要两个样本才能生成区间概念
            return;
        }

        // 1) 优先尝试归入现有范围概念（扩张量最小）
        范围概念信息* 最佳范围 = nullptr;
        double 最小扩张量 = std::numeric_limits<double>::infinity();

        for (auto& 范围 : 范围列表) {
            double 新最小 = std::min(范围.最小值, 新值);
            double 新最大 = std::max(范围.最大值, 新值);
            double 原长度 = (范围.最大值 - 范围.最小值);
            double 新长度 = (新最大 - 新最小);
            double 扩张量 = 新长度 - 原长度;

            if (扩张量 < 最小扩张量) {
                最小扩张量 = 扩张量;
                最佳范围 = &范围;
            }
        }

        // 简单阈值：扩张量小于原长度一半，就归入该范围
        if (最佳范围 && 最小扩张量 <= (最佳范围->最大值 - 最佳范围->最小值) * 0.5) {
            重新挂接到新父(
                static_cast<基础信息节点类*>(新样本节点),
                static_cast<基础信息节点类*>(最佳范围->概念节点)
            );

            最佳范围->最小值 = std::min(最佳范围->最小值, 新值);
            最佳范围->最大值 = std::max(最佳范围->最大值, 新值);
            最佳范围->成员叶子.push_back(新样本节点);
            return;
        }

        // 2) 否则：寻找一个最近的“孤立样本”，生成新的区间概念节点
        特征节点类* 最近样本 = nullptr;
        double 最小距离 = std::numeric_limits<double>::infinity();

        for (auto* 候选 : 样本列表) {
            if (!候选 || 候选 == 新样本节点) continue;
            if (样本属于某个范围(记录, 候选)) continue;

            auto* 候主信息 = dynamic_cast<特征节点主信息类*>(候选->主信息);
            if (!候主信息 || !候主信息->值) continue;
            auto* 候值节点 = static_cast<特征值节点类*>(候主信息->值);
            if (!候值节点 || !候值节点->主信息) continue;

            auto* 候值主信息 = dynamic_cast<特征值基类*>(候值节点->主信息);
            if (!候值主信息) continue;

            double 候值 = 0.0;
            if (!候值主信息->转为标量(候值)) continue;

            double d = std::abs(候值 - 新值);
            if (d < 最小距离) {
                最小距离 = d;
                最近样本 = 候选;
            }
        }

        if (!最近样本) {
            // 找不到合适的伙伴，就先作为孤立样本挂在 类型节点 下
            return;
        }

        // 取最近样本的标量值
        double 最近值 = 0.0;
        if (auto* 候主信息 = dynamic_cast<特征节点主信息类*>(最近样本->主信息)) {
            if (auto* 候值节点 = static_cast<特征值节点类*>(候主信息->值)) {
                if (auto* 候值主信息 = dynamic_cast<特征值基类*>(候值节点->主信息)) {
                    (void)候值主信息->转为标量(最近值);
                }
            }
        }

        // 创建新的范围概念节点（类型=同一个特征类型，值=暂时为 nullptr）
        auto* 类型词 = 记录.特征类型词;
        auto* 范围主信息 = new 特征节点主信息类(
            /*名*/ nullptr,
            /*型*/ 类型词,
            /*值*/ nullptr
        );
        基础信息基类* 基类指针 = 范围主信息;

        auto* 新概念节点 = static_cast<特征节点类*>(
            宇宙链.添加子节点(类型节点, 基类指针)
            );

        范围概念信息 新范围;
        新范围.概念节点 = 新概念节点;
        新范围.最小值 = std::min(新值, 最近值);
        新范围.最大值 = std::max(新值, 最近值);
        新范围.成员叶子 = { 最近样本, 新样本节点 };

        重新挂接到新父(
            static_cast<基础信息节点类*>(最近样本),
            static_cast<基础信息节点类*>(新概念节点)
        );
        重新挂接到新父(
            static_cast<基础信息节点类*>(新样本节点),
            static_cast<基础信息节点类*>(新概念节点)
        );

        范围列表.push_back((新范围));
    }

    //========================================================
    // 矢量 / 字符串特征值：相似簇概念（预留接口）
    //
    // 当前先不具体实现，只是把样本登记到 记录.样本节点列表 里，
    // 将来你可以在这里：
    //   - 用相似度算法（轮廓/坐标/embedding）做聚类
    //   - 为每个簇创建一个“相似簇概念节点”，结构类似 范围概念信息
    //========================================================
    void 自动归纳_相似簇(
        特征类型概念记录& 记录,
        特征节点类* 新样本节点,
        特征值基类* 新值主信息)
    {
        (void)记录;
        (void)新样本节点;
        (void)新值主信息;

        // TODO:
        //  - 根据 特征类型词 + 特征值 类型(矢量/字符串) 决定相似度算法
        //  - 计算与已有样本/簇的相似度
        //  - 将相似的样本归入同一簇；二值合并时生成“相似簇概念节点”
    }
};
