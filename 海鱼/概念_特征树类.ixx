export module 特征概念树模块;

import <vector>;
import <unordered_map>;
import <string>;
import <limits>;
import <cmath>;
import <algorithm>;

import 模板模块;
import 主信息定义模块;
import 宇宙链模块;

using std::vector;
using std::unordered_map;
using std::string;

//==============================
//  辅助结构：范围概念信息
//==============================

// 某一个“范围特征概念节点”的扩展信息
//  - 概念节点：特征节点类*（在宇宙链上）
//  - 最小值 / 最大值：当前覆盖的标量范围（简单版本）
//  - 成员叶子：目前归类到这个范围概念下的样本节点（叶子）
export struct 范围概念信息 {
    特征节点类* 概念节点 = nullptr;
    double       最小值 = 0.0;
    double       最大值 = 0.0;
    vector<特征节点类*> 成员叶子;
};

// 某一个特征类型（颜色 / 身高 / 体重 …）在特征概念树中的索引信息
export struct 特征类型概念记录 {
    词性节点类* 特征类型词 = nullptr;   // 比如 "身高"、"颜色"
    特征节点类* 类型节点 = nullptr;   // 根链上的“无值类型节点”
    vector<特征节点类*> 样本节点列表;     // 所有样本叶子（不管是否已经被归类）
    vector<范围概念信息> 范围概念列表;    // 已经出现的中间“范围概念节点”
};

//==============================
//  特征概念树
//==============================

export class 特征概念树类 {
private:
    // 整棵特征概念树的根（挂在 宇宙链.根指针 下面）
    特征节点类* 根_特征概念 = nullptr;

    // key = 特征类型词的 主键
    unordered_map<string, 特征类型概念记录> 类型表;

public:
    特征概念树类() = default;

    // 初始化：在宇宙链根下创建“特征概念_根”节点，清空所有记录
    void 初始化默认特征概念树() {
        根_特征概念 = nullptr;
        类型表.clear();

        auto* 主信息 = new 特征节点主信息类();
        基础信息基类* 基类指针 = 主信息;

        根_特征概念 = static_cast<特征节点类*>(
            宇宙链.添加子节点(宇宙链.根指针, 基类指针)
            );
        根_特征概念->主键 = "特征概念_根";
    }

    特征节点类* 获取根节点() const { return 根_特征概念; }

    const unordered_map<string, 特征类型概念记录>& 获取类型表() const {
        return 类型表;
    }

    //========================================
    // 1) 获取 / 创建 某个特征类型的“类型节点”
    //    特征概念_根 的子链上：只有类型、无值
    //========================================
    特征节点类* 获取或创建类型节点(词性节点类* 特征类型词) {
        if (!特征类型词) return nullptr;
        if (!根_特征概念) {
            初始化默认特征概念树();
        }

        const string& key = 特征类型词->主键;
        auto it = 类型表.find(key);
        if (it != 类型表.end()) {
            return it->second.类型节点;
        }

        // 新建一个“类型节点”：类型 = 特征类型词, 值 = nullptr
        auto* 主信息 = new 特征节点主信息类(
            /*名*/ nullptr,
            /*型*/ 特征类型词,
            /*值*/ nullptr
        );
        基础信息基类* 基类指针 = 主信息;

        auto* 类型节点 = static_cast<特征节点类*>(
            宇宙链.添加子节点(根_特征概念, 基类指针)
            );

        特征类型概念记录 记录;
        记录.特征类型词 = 特征类型词;
        记录.类型节点 = 类型节点;

        类型表.emplace(key, std::move(记录));
        return 类型节点;
    }

    //========================================
    // 2) 在某个特征类型下面添加一个“样本叶子节点”
    //
    //  - 特征类型词：比如“身高”“颜色”
    //  - 特征值节点：世界树那边产生的具体特征值（170cm / RGB...）
    //
    //  过程：
    //   1. 永远先在“类型节点”下面挂一个样本叶子
    //   2. 调用 自动归纳分类()，尝试在中间长出 / 归入“范围概念节点”
    //========================================
    特征节点类* 添加特征值样本(
        词性节点类* 特征类型词,
        特征值节点类* 特征值节点)
    {
        if (!特征类型词 || !特征值节点) return nullptr;

        auto* 类型节点 = 获取或创建类型节点(特征类型词);
        if (!类型节点) return nullptr;

        auto* 主信息 = new 特征节点主信息类(
            /*名*/ nullptr,
            /*型*/ 特征类型词,
            /*值*/ 特征值节点
        );
        基础信息基类* 基类指针 = 主信息;

        auto* 样本节点 = static_cast<特征节点类*>(
            宇宙链.添加子节点(类型节点, 基类指针)
            );

        auto& 记录 = 类型表[特征类型词->主键];
        记录.样本节点列表.push_back(样本节点);

        自动归纳分类(记录, 样本节点);

        return 样本节点;
    }

private:
    //========================================================
    // 工具：从“特征值节点”提取一个标量 double
    //
    // 当前版本：先留一个最简框架，等你特征值模块确定后再具体实现：
    //   - 如果是非矢量数值（int/float），直接转换为 double
    //   - 如果是矢量（比如 RGB），可以取亮度或某个通道
    //
    // 现在默认返回 false，不做归纳，只是给出接口位置。
    //========================================================
    static bool 提取标量特征值(特征值节点类* 值节点, double& out) {
        if (!值节点 || !值节点->主信息) return false;

        auto* 基 = dynamic_cast<特征值基类*>(值节点->主信息);
        if (!基) return false;

        // TODO: 根据你在“特征值模块”中的具体设计，从 特征值基类 派生类里提取标量。
        // 例如：
        //   if (auto* 标量 = dynamic_cast<标量特征值主信息类*>(基)) {
        //       out = 标量->值;
        //       return true;
        //   }
        //   if (auto* 向量 = dynamic_cast<矢量特征值主信息类*>(基)) {
        //       out = 向量->某个分量或范数;
        //       return true;
        //   }
        //
        // 这里先占位，等你特征值实现后再补。

        (void)基;
        (void)out;
        return false;
    }

    //========================================================
    // 工具：判断某个样本叶子是否已经属于某个范围概念
    //========================================================
    static bool 属于某个范围概念(
        const 特征类型概念记录& 记录,
        特征节点类* 样本节点)
    {
        for (const auto& 范围 : 记录.范围概念列表) {
            for (auto* 成员 : 范围.成员叶子) {
                if (成员 == 样本节点) return true;
            }
        }
        return false;
    }

    //========================================================
    // 工具：把一个节点“挂接到新的父节点”下面
    //
    // 注意：
    //   - 只修改 父/子/上/下/根，不动 链上/链下（仍在同一条宇宙链中）
    //   - 假定：节点属于 宇宙链<基础信息基类*>，即 基础信息节点类*
    //========================================================
    static void 重新挂接到新父(
        基础信息节点类* 节点,
        基础信息节点类* 新父)
    {
        if (!节点 || !新父) return;
        if (节点->父 == 新父) return;

        // 1. 先从旧父节点的子链中摘除
        auto* 旧父 = 节点->父;
        if (旧父) {
            if (旧父->子 == 节点) {
                // 当前是旧父的“子链入口”
                if (节点->下 == 节点) {
                    // 只有这一个子
                    旧父->子 = nullptr;
                }
                else {
                    // 有多个子，入口指针需要调整到下一个
                    旧父->子 = 节点->下;
                    节点->上->下 = 节点->下;
                    节点->下->上 = 节点->上;
                }
            }
            else {
                // 自环中间位置，直接断开
                节点->上->下 = 节点->下;
                节点->下->上 = 节点->上;
            }
            旧父->变更子节点数量(-1);
        }

        // 2. 挂到新父下面（不修改链上/链下，只调整同层环 + 父/根）
        if (!新父->子) {
            // 新父暂无子，节点自己形成子环
            新父->子 = 节点;
            节点->上 = 节点;
            节点->下 = 节点;
            节点->根 = 节点;
            节点->父 = 新父;
        }
        else {
            // 插入到 新父->子 的环中（和 添加子节点 的逻辑类似，但不更新主键/链指针）
            auto* 首子 = 新父->子;
            节点->上 = 首子->上;
            节点->下 = 首子;
            节点->根 = 首子->根;
            节点->父 = 新父;

            首子->上->下 = 节点;
            首子->上 = 节点;
        }
        新父->变更子节点数量(1);
    }

    //========================================================
    // 核心：自动归纳分类（中间生长型）
    //
    // 逻辑简化版：
    //   - 每个特征类型 T 单独处理
    //   - 每个新样本值 v_new：
    //       1）先尝试加入现有某个范围概念（扩张范围最小的）
    //       2）如果范围列表为空，或者扩张过大：
    //            * 寻找最近的“孤立样本 v_old”
    //            * 用 {v_new, v_old} 生成一个新的“范围概念节点”，挂在 类型节点 下
    //========================================================
    void 自动归纳分类(
        特征类型概念记录& 记录,
        特征节点类* 新样本节点)
    {
        if (!新样本节点 || !新样本节点->主信息) return;

        auto* 主信息 = dynamic_cast<特征节点主信息类*>(新样本节点->主信息);
        if (!主信息 || !主信息->值) return;

        double 新值 = 0.0;
        if (!提取标量特征值(
            static_cast<特征值节点类*>(主信息->值),
            新值)) {
            // 暂时无法转换成标量，则不做归纳（但样本已保存）
            return;
        }

        auto& 样本列表 = 记录.样本节点列表;
        auto& 范围列表 = 记录.范围概念列表;
        auto* 类型节点 = 记录.类型节点;

        if (!类型节点) return;

        // 样本数 <=1 时，仅记录，不生成概念
        if (样本列表.size() <= 1) {
            return;
        }

        // ---- 3. 优先尝试归入现有范围概念 ----
        范围概念信息* 最佳范围 = nullptr;
        double 最小扩张量 = std::numeric_limits<double>::infinity();

        for (auto& 范围 : 范围列表) {
            double 新最小 = std::min(范围.最小值, 新值);
            double 新最大 = std::max(范围.最大值, 新值);
            double 原长度 = (范围.最大值 - 范围.最小值);
            double 新长度 = (新最大 - 新最小);
            double 扩张量 = 新长度 - 原长度;

            if (扩张量 < 最小扩张量) {
                最小扩张量 = 扩张量;
                最佳范围 = &范围;
            }
        }

        // 一个简单阈值策略：如果扩张量相对原长度不太夸张，就归入
        if (最佳范围 && 最小扩张量 <= (最佳范围->最大值 - 最佳范围->最小值) * 0.5) {
            // 挂到这个范围节点下面
            重新挂接到新父(
                static_cast<基础信息节点类*>(新样本节点),
                static_cast<基础信息节点类*>(最佳范围->概念节点)
            );

            // 更新范围统计
            最佳范围->最小值 = std::min(最佳范围->最小值, 新值);
            最佳范围->最大值 = std::max(最佳范围->最大值, 新值);
            最佳范围->成员叶子.push_back(新样本节点);
            return;
        }

        // ---- 4. 否则：寻找一个最近的“孤立样本”，与之合成新的中间概念节点 ----
        特征节点类* 最近样本 = nullptr;
        double 最小距离 = std::numeric_limits<double>::infinity();

        for (auto* 候选 : 样本列表) {
            if (!候选 || 候选 == 新样本节点) continue;
            // 已经属于某个范围概念，则跳过（不再参与新的成对合并）
            if (属于某个范围概念(记录, 候选)) continue;

            auto* 候主 = dynamic_cast<特征节点主信息类*>(候选->主信息);
            if (!候主 || !候主->值) continue;

            double 候选值 = 0.0;
            if (!提取标量特征值(
                static_cast<特征值节点类*>(候主->值),
                候选值)) {
                continue;
            }

            double d = std::abs(候选值 - 新值);
            if (d < 最小距离) {
                最小距离 = d;
                最近样本 = 候选;
            }
        }

        if (!最近样本) {
            // 找不到合适伙伴，就暂时当作孤立样本留在 类型节点 下
            return;
        }

        // 提取最近样本的数值
        double 最近值 = 0.0;
        if (auto* 候主 = dynamic_cast<特征节点主信息类*>(最近样本->主信息)) {
            (void)提取标量特征值(
                static_cast<特征值节点类*>(候主->值),
                最近值
            );
        }

        // ---- 5. 在类型节点下面创建一个新的“范围概念节点” ----
        auto* 类型词 = 记录.特征类型词;
        auto* 范围主信息 = new 特征节点主信息类(
            /*名*/ nullptr,
            /*型*/ 类型词,
            /*值*/ nullptr   // 将来可以换成一个真正表示“区间[min,max]”的特征值节点
        );
        基础信息基类* 基类指针 = 范围主信息;

        auto* 新概念节点 = static_cast<特征节点类*>(
            宇宙链.添加子节点(类型节点, 基类指针)
            );

        范围概念信息 新范围;
        新范围.概念节点 = 新概念节点;
        新范围.最小值 = std::min(新值, 最近值);
        新范围.最大值 = std::max(新值, 最近值);
        新范围.成员叶子 = { 最近样本, 新样本节点 };

        // 把两个样本节点挂到新概念节点下面
        重新挂接到新父(
            static_cast<基础信息节点类*>(最近样本),
            static_cast<基础信息节点类*>(新概念节点)
        );
        重新挂接到新父(
            static_cast<基础信息节点类*>(新样本节点),
            static_cast<基础信息节点类*>(新概念节点)
        );

        范围列表.push_back(std::move(新范围));
    }
};
