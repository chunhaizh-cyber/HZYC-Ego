export module 语言知识库模块;

import <string>;
import <vector>;
import <functional>;

import 主信息定义模块;    // 自然语言成分基类、场景主信息类等
import 世界树模块;        // 世界树类, 节点类, 场景节点类 等
import 自然语言树模块;    // 文章/段落/自然句/子句 主信息 + 自然句节点类/子句节点类
import 语素模块;          // 词性节点类 等
import 模板模块;


export class 自然语言知识库类 {
public:
    // 方便起见，给一个句子词序列的别名
    using 词序列类型 = std::vector<词性节点类*>;

    // 一个子句匹配结果：类型 + 区间
    struct 子句匹配结果 {
        枚举_原子结构类型 类型 = 枚举_原子结构类型::未定义;
        std::size_t 起始 = 0;   // [起始, 结束)
        std::size_t 结束 = 0;
    };

    // “对整句做扫描”的匹配函数：
    // 输入：整句词序列
    // 输出：把自己能识别到的所有子句区间 push_back 到 输出列表
    using 原子结构匹配函数 =std::function<void(const 词序列类型& 整句词序列,std::vector<子句匹配结果>& 输出列表)>;

    // “对单个子句做语义融合”的函数：
    // 输入：子句主信息指针 + 世界树 + 默认场景
    // 返回：是否融合成功（便于统计）
    using 原子结构融合函数 =std::function<bool(子句主信息类* 子句,世界树类& 世界树,场景节点类* 默认场景)>;

    // 知识库中的一条“原子结构条目”
    struct 原子结构条目 {
        枚举_原子结构类型 类型 = 枚举_原子结构类型::未定义;
        std::string 名称;              // 可读名称，比如 “时间定位”
        原子结构匹配函数 匹配器;       // 扫描整句，找出所有子句区间
        原子结构融合函数 融合器;       // 对一个子句做具体融合
    };

public:
    // === 核心接口 ===
    // 输入一个自然句节点：
    // 1. 取出 自然句主信息 与 词序列
    // 2. 对 17 种原子结构逐个调用“匹配器”，收集所有子句区间
    // 3. 按区间生成 子句主信息类 + 子句节点，挂到 自然句节点 子链上
    // 4. 对每个子句调用对应的“融合器”，把信息写入世界树
    static bool 融合自然句(自然句节点类* 自然句节点,世界树类& 世界树,场景节点类* 默认场景);

private:
    // 懒加载的原子结构库（17 条）
    static std::vector<原子结构条目>& 原子结构库();
    void 融合整篇文章(文章节点类* 文章, 世界树类& 世界树);


    // 辅助：根据 自然句节点 推断默认场景（如果调用者没传）
    static 场景节点类* 推断默认场景(自然句节点类* 自然句节点,世界树类& 世界树,场景节点类* 显式默认场景);
    using 融合函数 =
        std::function<bool(const std::vector<词性节点类*>& 词序列,
            世界树类& 世界树,
            场景节点类* 场景)>;

    struct 表达结构 {
        std::string 名称;       // 用途名称：空间位置 / 比较 / 条件...
        std::string 模板模式;   // 仅做说明用，比如 "{N} 在 {地点}"
        融合函数    融合器;     // 真正干活的函数
    };

    // 主入口：依次尝试 17 个原子用途的融合函数
    static bool 尝试融合(const std::vector<词性节点类*>& 词序列,世界树类& 世界树,场景节点类* 场景)
    {
        for (const auto& 结构 : 获取知识库()) {
            if (结构.融合器 &&
                结构.融合器(词序列, 世界树, 场景)) {
                return true;
            }
        }
        return false;
    }

private:
    static const std::vector<表达结构>& 获取知识库();

    // 17 个原子用途对应的融合函数
//    static bool 融合_空间位置(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_时间定位(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_比较排序(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_数量范围(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_否定排除(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_疑问需求(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_条件假设(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_因果解释(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_时间体貌(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_评价立场(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_来源引述(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_定义分类(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_角色标注(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_约束义务(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_例外对照(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_单位度量(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//    static bool 融合_指代省略(const std::vector<词性节点类*>&, 世界树类&, 场景节点类*);
//
//    // 一些简单的辅助函数（需要你根据自己的 词性节点类 做适配）
//    static std::string 取词文本(const 词性节点类* 节点);
//    static bool 文本等于(const 词性节点类* 节点, const std::string& 文本);
//
//    static bool 是时间词(const 词性节点类* 节点);
//    static bool 是否定词(const 词性节点类* 节点);
//    static bool 是疑问标记(const 词性节点类* 节点);
//    static bool 是条件连词(const 词性节点类* 节点);
//    static bool 是因果连词_原因(const 词性节点类* 节点);
//    static bool 是因果连词_结果(const 词性节点类* 节点);
//    static bool 是比较标记(const 词性节点类* 节点);
//    static bool 是模态词(const 词性节点类* 节点);
//    static bool 是例外标记(const 词性节点类* 节点);
//    static bool 是单位词(const 词性节点类* 节点);
//    static bool 是代词_指代(const 词性节点类* 节点);
//
//    static bool 是数字串(const std::string& s);
    static double 解析数字(const std::string& s);
};

// ====== 知识库初始化 ======


bool 自然语言知识库类::融合自然句(自然句节点类* 自然句节点, 世界树类& 世界树, 场景节点类* 默认场景)
{
    return false;
}

const std::vector<自然语言知识库类::表达结构>&
自然语言知识库类::获取知识库()
{
    static const std::vector<表达结构> 知识库;// = {
//        { "空间位置",   "{N} 在 {地点}",      &自然语言知识库类::融合_空间位置 },
//        { "时间定位",   "{事件} 在 {时间}",   &自然语言知识库类::融合_时间定位 },
//        { "比较排序",   "{N1} 比 {N2} 更 {形容词}", &自然语言知识库类::融合_比较排序 },
//        { "数量范围",   "{N} 有 {数量}",      &自然语言知识库类::融合_数量范围 },
//        { "否定排除",   "不 / 没有 / 不是",   &自然语言知识库类::融合_否定排除 },
//        { "疑问需求",   "吗 / 什么 / 谁 / 哪儿", &自然语言知识库类::融合_疑问需求 },
//        { "条件假设",   "如果 … 就 …",       &自然语言知识库类::融合_条件假设 },
//        { "因果解释",   "因为 … 所以 …",     &自然语言知识库类::融合_因果解释 },
//        { "时间体貌",   "正在 / 已经 / 还没", &自然语言知识库类::融合_时间体貌 },
//        { "评价立场",   "好 / 坏 / 喜欢 / 讨厌", &自然语言知识库类::融合_评价立场 },
//        { "来源引述",   "A 说 B / 据 A 说 B",   &自然语言知识库类::融合_来源引述 },
//        { "定义分类",   "A 是 B / A 属于 B",   &自然语言知识库类::融合_定义分类 },
//        { "角色标注",   "A 给 B C / A 从 B 拿 C", &自然语言知识库类::融合_角色标注 },
//        { "约束义务",   "必须 / 应该 / 可以", &自然语言知识库类::融合_约束义务 },
//        { "例外对照",   "除了 A 以外 B",     &自然语言知识库类::融合_例外对照 },
//        { "单位度量",   "3 米 / 5 公斤",     &自然语言知识库类::融合_单位度量 },
//        { "指代省略",   "他 / 她 / 它 / 那里 / 这样", &自然语言知识库类::融合_指代省略 },
//    };
    return 知识库;
}

