// 世界树模块.ixx
export module 世界树模块;
import <vector> ;
import 基础数据类型模块;
import 主信息定义模块; 
import 语素模块;
import 宇宙链模块;

export class 世界树类 {
public:
    using 节点类型 = 基础信息节点类;
    场景节点类* 根场景 = nullptr;  // 现实世界根场景（在 宇宙链 上的一棵子树）
    存在节点类* 自我指针 = nullptr;
    场景节点类* 自我所在场景 = nullptr;
private:
  
    
public:
    世界树类() = default;
    ~世界树类() = default;

    世界树类(const 世界树类&) = delete;
    世界树类& operator=(const 世界树类&) = delete;
    世界树类(世界树类&&) = default;
    世界树类& operator=(世界树类&&) = default;

    // 初始化默认世界：在 宇宙链.根指针 下新建一个“根场景”
    void 初始化默认世界() {     
        auto* 主信息 = new 场景节点主信息类();  // 名称、世界层级等你在定义里补
	//	auto* 自我词性节点 = 语素集.添加词性词("", "代词");
        auto* 自我存在主信息 = new 存在节点主信息类();
         自我所在场景=宇宙链.添加子节点(根场景, 主信息);//添加自我所在场景
        自我指针=宇宙链.添加子节点(自我所在场景,自我存在主信息);//添加自我存在节点        
        
    }

    //生成一个空白场景,并放在世界树根链上,可以有许多,会定期清除
    场景节点类* 添加场景() {
        auto* 主信息 = new 场景节点主信息类();         
        auto* 节点 = 宇宙链.添加子节点(根场景, 主信息);
        return 节点;       
	}
	//根据名称和上级场景生成一个新场景
    场景节点类* 添加场景(std::string 名称,场景节点类* 父场景 = nullptr) {
        if (!父场景) {
            父场景 = 根场景;
        }
        auto* 主信息 = new 场景节点主信息类();
		词性节点类* 名称词性节点 = 语素集.添加词性词(名称, "专有名词");
        主信息->名称 = 名称词性节点;		
        基础信息基类* 基类指针 = 主信息;
        auto* 节点 = 宇宙链.添加子节点(父场景, 基类指针);        
        return 节点;
	}
    场景节点类* 获取根场景() const { return 根场景; }

    // 在某个场景下新建一个“存在实例”
    存在节点类* 新建存在(场景节点类* 所在场景, 存在节点主信息类* 主信息);

    // 给某个存在实例挂一个特征（颜色、形状、位置等）
    特征节点类* 为存在添加特征(存在节点类* 存在, 特征节点主信息类* 特征主信息);

  
    // 世界树类.ixx 或实现文件

// 1. 查找某个存在下，指定类型 + 指定值的特征节点（精确匹配）
    特征节点类* 查找特征节点_类型加值(存在节点类* 存在,词性节点类* 特征类型,特征值节点类* 目标特征值) const;

    // 2. 检查某个存在是否已经拥有某个具体特征值（常用于查重）
    bool 是否存在该特征值(存在节点类* 存在, 词性节点类* 特征类型, 特征值节点类* 目标特征值) const;

    // 3. 只按类型查找（返回第一个匹配的特征节点）—— 仍保留，用于读取“当前最新”或“唯一”特征的情况
    特征节点类* 查找特征节点(存在节点类* 存在, 词性节点类* 特征类型) const;

    // 4. （可选）返回指定类型的所有特征节点（如果一个类型允许多个独立特征节点）
    std::vector<特征节点类*> 查找所有特征节点(存在节点类* 存在, 词性节点类* 特征类型) const;
};


