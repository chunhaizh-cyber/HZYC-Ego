// ======================== 世界树模块.ixx ========================
export module 世界树模块;

import 模板模块;
import 主信息定义模块;
import 语素模块;
//import 全局变量模块;   // 为了拿到 宇宙链表 和 语素集

import <string>;
import <vector>;
import <iostream>;

export class 世界树类 {
public:
    // 世界树节点统一用这一种节点类型
    using 节点类 = 链表模板<基础信息基类*>::节点类;
    using 场景节点类 = 节点类;
    using 存在节点类 = 节点类;
    using 特征节点类 = 节点类;

private:
    // 语义上的“世界根场景”（注意：不是 宇宙链表 的根指针）
    场景节点类* 世界根 = nullptr;

public:
    世界树类();

    // ============ 基本访问接口 ============

    场景节点类* 获取世界根() const { return 世界根; }

    // 兼容以前的命名（如果你以前用的是 取根场景 / 取根 / Root 之类可以再加别名）
    场景节点类* 获取根场景() const { return 世界根; }

    // ============ 场景相关 ============

    // 新建一个场景节点（默认挂到世界根下面）
    场景节点类* 新建场景(const std::string& 场景名,
        场景节点类* 上级场景 = nullptr);

    // 兼容老命名：添加场景(...)
    场景节点类* 添加场景(const std::string& 场景名,
        场景节点类* 上级场景 = nullptr) {
        return 新建场景(场景名, 上级场景);
    }

    // 按“场景名称词性节点”查找场景：
    // - 如果提供上级场景，则只在该场景子链里找
    // - 如果上级场景为空，则在整个宇宙链表里查找全部场景节点
    场景节点类* 查找场景(场景节点类* 上级场景,
        词性节点类* 场景名称);

    // ============ 存在相关 ============

    // 基于“概念主信息”在某个场景下创建存在实例（路线 A：主信息可来自概念树）
    存在节点类* 新建存在实例(基础信息基类* 概念主信息,
        场景节点类* 所在场景 = nullptr);

    // 兼容老命名：添加存在(场景, 存在主信息)
    存在节点类* 添加存在(场景节点类* 所在场景,基础信息基类* 概念主信息) {
        return 新建存在实例(概念主信息, 所在场景);
    }

    // ============ 特征相关 ============

    // 在任意节点下添加一个“特征节点”
    // 这里仅实现最常用的「名称 + 一组整数值」版本
    //////////////////////////标量,不带单位,一个或多个整数////////////////////////////////////////

    特征节点类* 添加特征(节点类* 所属节点,const std::string& 特征名,const std::vector<std::int64_t>& 数值);
    特征节点类* 添加特征(节点类* 所属节点, const std::string& 特征名, std::int64_t 数值);
    /////////////////////////矢量-带单位,一个整数////////////////////////////////////////////////////////////////
    特征节点类* 添加特征(节点类* 所属节点, const std::string& 特征名, std::int64_t 数值,std::string 单位);
    // 如有需要，你可以再根据类型重载：
    // 特征节点类* 添加特征(节点类*, 词性节点类* 特征名, 特征值基类* 值) 等

    基础信息节点类* 世界树_根据词性创建默认基础信息节点(词性节点类* 基础信息名称, 枚举_词性 词性);
    二次特征节点类* 添加二次特征(存在节点类* 添加位置, 二次特征主信息类* 二次特征主信息);

    存在节点类* 确保存在(场景节点类* 场景, 词节点类* 词);
    存在节点类* 确保抽象场所(场景节点类* 场景, const std::string& 名称);
    存在节点类* 确保抽象类别(场景节点类* 场景, const std::string& 名称);
    存在节点类* 确保抽象来源(场景节点类* 场景, const std::string& 名称);
    动态节点类* 记录文本事件(场景节点类* 场景, const std::string& 描述);
    void 记录空间位置(存在节点类* 主体, 存在节点类* 场所, const std::string& 关系名);
    void 记录时间定位(存在节点类* 锚, const std::string& 时间表达);
    void 记录比较关系(存在节点类* A, 存在节点类* B, ...);
  

public:
    // 获取已有内部世界；若不存在则创建一个
    场景节点类* 获取或创建内部世界(存在节点类* 宿主存在);

    // 只读：已经存在才返回，不创建
    场景节点类* 取内部世界(存在节点类* 宿主存在) const;

private:
    词性节点类* 构造内部世界名称(存在节点类* 宿主存在);

};

