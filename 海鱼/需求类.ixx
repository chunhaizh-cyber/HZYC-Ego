module;
#include <cassert>
#include <iostream>
#include <string>
#include <vector>

export module 需求模块;

import 基础数据类型模块;
import 模板模块;
import 主信息定义模块;


 





export class 需求类 :private 链表模板<高级信息基类*> {
public:
	存在节点类* 主体;
	int64_t 获取加权值(节点类* 父节点);
	void 更新权重(需求节点类* 当前节点) {
		if (当前节点 == nullptr) {
			return; // 基本安全检查
		}
		int64_t 总权重值;
		if (当前节点->父 == nullptr) {
			// 情况1：如果链头的父节点为空，则认为整条链属于"根链"
			总权重值 = std::numeric_limits<int64_t>::max(); // 使用64位整数最大值
		}
		else {
			// 情况2：非根链，使用父节点的权重（这里假设父节点有`需求权重`成员）
			// 注意：你需要根据实际的权重信息存储位置修改这里
			
			需求主信息类* 需求主信息 = dynamic_cast<需求主信息类*> (当前节点->父->主信息);
			总权重值 = 需求主信息->权重; // 假设权重存储在`主信息`成员中
		}
		int64_t 平均权重 = 总权重值 / 当前节点->获取子节点数量(); // 整数除法自然向下取整
		需求主信息类* 需求主信息 = dynamic_cast<需求主信息类*> (当前节点->子->主信息);

		需求主信息->权重 = 平均权重;
		节点类* 遍历指针 = 当前节点->子->下;
		while (遍历指针 != 当前节点->子) {
			// 同样，这里需要根据你实际的权重存储位置来赋值
			// 例如，如果权重是节点类本身的成员：遍历指针->权重 = 平均权重;
			// 或者，如果权重存储在主信息中：遍历指针->主信息.需求权重 = 平均权重;
			需求主信息 = dynamic_cast<需求主信息类*> (遍历指针->主信息);
			需求主信息->权重 = 平均权重;			
			遍历指针 = 遍历指针->下;
		}
	}
	需求节点类* 新增子需求(需求节点类* 父节点, 需求节点类* 节点) {
		return 添加子节点(父节点, 节点);
	}
	需求节点类* 新增需求(存在节点类* 主体_, 存在节点类* 目标_, 状态节点类* 需求状态_) {
		需求主信息类* 主信息_ = new 需求主信息类(主体_, 目标_, 需求状态_);
		需求节点类* 新节点 = new 需求节点类();
		新节点->主信息 = 主信息_;
		return 添加节点(根指针, 新节点);
	}
	
	
	void 整理需求归属();
	需求节点类* 查找需求_按主体(节点类* 父节点, 存在节点类* 主体);
	需求节点类* 查找需求_按对象(节点类* 父节点, 存在节点类* 对象);
};



export 需求类 需求集;
