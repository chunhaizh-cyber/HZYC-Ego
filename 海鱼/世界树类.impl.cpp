
module 世界树模块;
import <stdexcept>;
import <vector>;
import <utility>;
import 模板模块;
import 主信息定义模块;
import 语素模块;
import 全局变量模块;



// ======================== 实现部分 ========================

世界树类::世界树类() {
    // 使用全局唯一的“宇宙链表”作为节点池
    auto& 宇宙树 = 全局变量::宇宙链表;

    // 创建“世界根场景”主信息
    auto* 主信息 = new 场景节点主信息类();

    // 名称：词性 = ("世界", "根场景")
    // 这里假定 语素集.添加词性词 已经统一改成 std::string 版本
    词性节点类* 名称词性 = 全局变量::语素集.添加词性词("世界", "根场景");
    主信息->名称 = 名称词性;

    // 挂到宇宙链表上（作为一个场景节点）
    世界根 = 宇宙树.添加节点(主信息);

    std::cout << "【世界树】世界根场景已创建\n";
}

// ============ 新建场景 ============

场景节点类* 世界树类::新建场景(const std::string& 场景名, 场景节点类* 上级场景) {
    auto& 宇宙树 = 全局变量::宇宙链表;

    if (!上级场景) {
        上级场景 = 世界根;
    }
    auto* 主信息 = new 场景节点主信息类();

    // 场景名称 → 语素集
    词性节点类* 名称词性 = 全局变量::语素集.添加词性词(场景名, "场景名");
    主信息->名称 = 名称词性;

    场景节点类* 新场景 = 宇宙树.添加子节点(上级场景, 主信息);

    std::cout << "【世界树】新建场景 [" << 场景名 << "]\n";
    return 新场景;
}

// ============ 查找场景 ============
//
// 需求回顾：
//   场景节点类* 世界树类::查找场景(场景节点类* 上级场景,
//                                  词性节点类* 场景名称)
// 逻辑：
//   - 若上级场景 != nullptr：在其子链中找「主信息是 场景节点主信息类 且 名称指针 == 场景名称」
//   - 若上级场景 == nullptr：在“宇宙链表”全局根链中遍历查找
//
场景节点类* 世界树类::查找场景(场景节点类* 上级场景, 词性节点类* 场景名称) {
    if (!场景名称) return nullptr;
    auto& 宇宙树 = 全局变量::宇宙链表;
    // 1) 有上级场景：在子链里查
    if (上级场景 && 上级场景->子) {
        场景节点类* 子起点 = 上级场景->子;
        场景节点类* 游标 = 子起点;

        do {
            if (auto* 场景主 = dynamic_cast<场景节点主信息类*>(游标->主信息)) {
                if (场景主->名称 == 场景名称) {
                    return 游标;
                }
            }
            游标 = 游标->下;
        } while (游标 && 游标 != 子起点);

        return nullptr;
    }

    // 2) 无上级场景：在整个宇宙根链上查找所有“场景节点”
    auto* 根 = 宇宙树.根指针;
    if (!根) return nullptr;

    节点类* 游标 = 根->链下;
    while (游标 && 游标 != 根) {
        if (auto* 场景主 =dynamic_cast<场景节点主信息类*>(游标->主信息)) {
            if (场景主->名称 == 场景名称) {
                return static_cast<场景节点类*>(游标);
            }
        }
        游标 = 游标->链下;
    }

    return nullptr;
}

// ============ 新建存在实例 ============
//
//   概念树路线 A：概念本体（基础信息）只有一份
//   这里的 概念主信息 既可以是“抽象概念主信息”，也可以是“专门为实例创建的主信息”
//   但就存储而言，都是一个 基础信息基类* 指针
//
存在节点类* 世界树类::新建存在实例(基础信息基类* 概念主信息, 场景节点类* 所在场景) {
    auto& 宇宙树 = 全局变量::宇宙链表;

    if (!概念主信息) {
        std::cerr << "【世界树】新建存在实例失败：概念主信息为空\n";
        return nullptr;
    }

    if (!所在场景) {
        所在场景 = 世界根;
    }

    存在节点类* 实例节点 =
        宇宙树.添加子节点(所在场景, 概念主信息);

    // 这里你可以根据需要，给“实例节点”加特征，比如时间戳 / 唯一ID等
    // （可以调用你已有的 添加特征 / 添加状态 / 添加动态 等接口）

    return 实例节点;
}

// ============ 添加特征 ============
//
//   目前只提供最简单的版本：
//      - 特征名：std::string
//      - 特征值：std::vector<std::int64_t>
//   更复杂的值类型（矢量特征值、非矢量特征值）可以再重载
//
特征节点类* 世界树类::添加特征(存在节点类* 所属节点, const std::string& 特征名, const std::vector<std::int64_t>& 数值)
{
    if (!所属节点) {
        std::cerr << "【世界树】添加特征失败：所属节点为空\n";
        return nullptr;
    }
    auto& 宇宙树 = 全局变量::宇宙链表;

    // 1. 创建特征主信息
    auto* 主信息 = new 特征节点主信息类();

    // 特征名称：放入语素集
    词性节点类* 名称词性 =  全局变量::语素集.添加词性词(特征名, "特征名");
    主信息->名称 = 名称词性;

    // TODO：根据你现有的 特征节点主信息类 结构，把“数值”写进去
    // 比如：
    //   - 如果你有 特征值基类* 值; 就在这里 new 对应的特征值对象
    //   - 或者有 std::vector<std::int64_t> 数值; 就直接赋值
    //
    // 示例（请按实际结构调整）：
    // 主信息->数值 = 数值;
    // 或：
    // 主信息->值 = new 非矢量特征值节点主信息类(数值);

    // 2. 挂到所属节点的子链上
    特征节点类* 特征节点 = 宇宙树.添加子节点(所属节点, 主信息);

    return 特征节点;
}
基础信息节点类* 世界树类::世界树_根据词性创建默认基础信息节点(词性节点类* 基础信息名称,枚举_词性 词性)
{
    auto& 宇宙树 = 全局变量::宇宙链表;
    if (!基础信息名称) return nullptr;

    基础信息基类* 主信息 = nullptr;

    switch (词性) {
    case 枚举_词性::名词:
    case 枚举_词性::代词:
        // 名词、代词 → “存在”
        主信息 = new 存在节点主信息类();
        break;

    case 枚举_词性::动词:
        // 动词 → “动态”
        主信息 = new 动态节点主信息类();
        break;

    case 枚举_词性::形容词:
    case 枚举_词性::副词:
    case 枚举_词性::数词:
    case 枚举_词性::量词:
        // 各种修饰词、数量词 → “特征”
        主信息 = new 特征节点主信息类();
        break;

    case 枚举_词性::介词:
    case 枚举_词性::连词:
        // 介词、连词：这里先简单映射到“场景/关系”类型
        主信息 = new 场景节点主信息类();
        break;

    default:
        // 助词、语气词、叹词等先不在世界树开基础节点，有需要再扩展
        return nullptr;
    }

    // 统一赋名 ―― 基类里有“名称”这个字段
    主信息->名称 = 基础信息名称;

    // 借助全局世界树，把这个主信息挂到世界树根链
    return static_cast<基础信息节点类*>(
        宇宙树.添加节点(世界根,主信息));
}
场景节点类* 世界树类::获取或创建内部世界(存在节点类* 宿主存在) {
    auto& 宇宙树 = 全局变量::宇宙链表;
    if (!宿主存在) return nullptr;

        // 1. 如果已经有，直接返回
        if (auto* 已有 = 取内部世界(宿主存在)) {
            return 已有;
        }

        // 2. 创建新的附属世界
        auto& 链 = 世界根;  // 或 this->链表

        auto* 场景主 = new 场景节点主信息类();
        场景主->宿主存在 = 宿主存在;
        场景主->世界类型 = 枚举_世界类型::附属世界;
        场景主->名称 = 构造内部世界名称(宿主存在);

        // 挂在场景根下面：形成独立的“世界”
        场景节点类* 新世界 = 宇宙树.添加子节点(世界根, 场景主);

        // 3. 写回存在主信息
        if (auto* 存在主 = dynamic_cast<存在节点主信息类*>(宿主存在->主信息)) {
            存在主->内部世界 = 新世界;
        }

        // （可选）再用特征记录一份，方便其它模块纯走特征体系
        // 标准特征工具::添加字符串特征(宿主存在, "内部世界", "节点引用_内部世界", 新世界->主键);

        return 新世界;
    }

    // 只读：已经存在才返回，不创建
场景节点类* 世界树类::取内部世界(存在节点类* 宿主存在) const {
        if (!宿主存在) return nullptr;
        auto* 存在主 = dynamic_cast<存在节点主信息类*>(宿主存在->主信息);
        return (存在主 ? 存在主->内部世界 : nullptr);
    }

词性节点类* 世界树类::构造内部世界名称(存在节点类* 宿主存在) {
    auto& 宇宙树 = 全局变量::宇宙链表;
        auto* 存在主 = dynamic_cast<存在节点主信息类*>(宿主存在->主信息);
        std::string 名 = "匿名存在";
        if (存在主 && 存在主->名称) {
            名 = 全局变量::概念树.取词面(存在主->名称);
        }
        std::string 全名 = 名 + "・内部世界";
        return 全局变量::语素集.添加词性词(全名, "场景名");
    }



 
