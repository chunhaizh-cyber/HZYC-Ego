module 概念引擎模块;
import 世界树模块;
import 主信息定义模块;

void 概念引擎类::处理新实例(节点类型* 节点) {
    if (!节点) return;

    auto* 主信息 = dynamic_cast<主信息类型*>(节点->主信息);
    if (!主信息) return;

    // 1. 没有“类型”的节点不参与概念生成
    if (!主信息->类型) return;

    // 类型主键：直接用 词性节点 的主键就行
    const std::string& 类型主键 = 主信息->类型->主键;

    // 2. 判断这是存在/特征/动态等哪一类
    if (auto* 存在主信息 = dynamic_cast<存在节点主信息类*>(主信息)) {
        处理某类(存在概念表, 类型主键, 节点, 枚举_概念类别::存在概念);
    }
    else if (auto* 特征主信息 = dynamic_cast<特征节点主信息类*>(主信息)) {
        处理某类(特征概念表, 类型主键, 节点, 枚举_概念类别::特征概念);
    }
    else if (auto* 动态主信息 = dynamic_cast<动态节点主信息类*>(主信息)) {
        处理某类(动态概念表, 类型主键, 节点, 枚举_概念类别::动态概念);
    }
    // ... 将来可以继续 else if 状态 / 因果 等
}

void 概念引擎类::处理某类(
    std::unordered_map<std::string, 概念统计项>& 表,
    const std::string& 类型主键,
    节点类型* 新节点,
    枚举_概念类别 概念类别)
{
    auto& 项 = 表[类型主键];
    项.次数 += 1;

    if (!项.示例1) {
        项.示例1 = 新节点;
        return; // 第一个实例，仅记录
    }
    if (!项.示例2) {
        项.示例2 = 新节点;
    }

    // 如果之前还没有概念对象，这次是“第二个实例”，就生成概念
    if (!项.概念对象) {
        项.概念对象 = 创建概念对象(类型主键, 概念类别, 项.示例1, 项.示例2);
        // 这里可以把概念挂到你之前的 概念_存在树 / 概念_特征树 里
        // 或者暂时只存下来，后面慢慢用
    }
    else {
        // 如果已经有概念，可以在这里更新概念（增加统计信息、调整典型值等）
        // TODO: 将来可扩展
    }
}


std::unique_ptr<概念基类> 概念引擎类::创建概念对象(
    const std::string& 类型主键,
    枚举_概念类别 概念类别,
    节点类型* 示例1,
    节点类型* 示例2)
{
    std::unique_ptr<概念基类> 概念;

    switch (概念类别) {
    case 枚举_概念类别::存在概念: {
        auto* p = new 存在概念类();
        概念.reset(p);
        break;
    }
    case 枚举_概念类别::特征概念: {
        auto* p = new 特征概念类();
        概念.reset(p);
        break;
    }
    case 枚举_概念类别::动态概念: {
        auto* p = new 动态概念类();
        概念.reset(p);
        break;
    }
    default:
        概念.reset(new 概念基类());
        break;
    }

    概念->概念类别 = 概念类别;
    概念->内部标识名 = 类型主键; // 先用 类型 的主键当内部名

    // TODO: 在这里分析 示例1 / 示例2 的特征，给概念填一点“典型特征”
    // 比如：平均尺寸、常见颜色、典型动态模式等等

    return 概念;
}