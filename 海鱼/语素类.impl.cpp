


module 语素模块;
// 词模块接口实现：统一词结构、树形组织、词性子节点、多实体引用
import <cassert>;
import <iostream>;
import <random>;
import <vector>;
import <string>;
import <cstdint>;  // for int64_t
import <chrono>;   // for steady_clock

import 主信息定义模块;
import 全局函数模块;
   

// 便捷重载：支持宽字面量


词节点类* 语素类::生成语素节点(结构体_分词 分词信息)
{
    return 添加词性词(分词信息.词, 分词信息.词性);
}

词节点类* 语素类::添加词(const std::string& 词字符串) {
    if (词字符串.empty()) {
        throw std::invalid_argument("词节点类* 语素类::添加词: 词字符串 为空!");
    }
        词节点类* 当前游标 = 根指针;   // 第 0 层在根环，其后在“上一命中”的子链
        词节点类* 当前节点 = nullptr;

        std::string 前缀;
        前缀.reserve(词字符串.size()); // 避免反复分配

        for (size_t i = 0; i < 词字符串.length(); ++i) {
            前缀.push_back(词字符串[i]); // 递增构建前缀
            词主信息类 临时主信息(前缀);
            // 查找当前前缀是否已存在
            当前节点 = (当前游标 == 根指针) ?
                查找节点_当前链(当前游标, &临时主信息, 枚举_比较字段::语素_词_词, 枚举_比较条件::相等) :
                查找节点_当前链(当前游标->子, &临时主信息, 枚举_比较字段::语素_词_词, 枚举_比较条件::相等);

            if (!当前节点) {
                词节点类* 新词节点 = new 词节点类();
                新词节点->主信息 = new 词主信息类(前缀);

                if (当前游标 == 根指针) {
                    当前节点 = 添加节点(当前游标, 新词节点);
                }
                else {
                    当前节点 = 添加子节点(当前游标, 新词节点);
                }
                if (!当前节点) {
                    // 处理添加节点失败的情况
                    delete 新词节点->主信息;
                    delete 新词节点;
                    return nullptr;
                }
            }
            // 更新游标，进入下一层
            当前游标 = 当前节点;
        }
        return 当前节点;  // 返回完整词节点
    
 }


词节点类* 语素类::查找词节点(const std::string& 词字符串) {
     if (词字符串.empty()) {
         throw std::invalid_argument("查找词节点 时, 词字符串 为空!");
     }
     return 查找词(词字符串); // 复用私有版“查找词(不创建)”
 }


词节点类* 语素类::查找词性节点(词节点类* 词节点, 枚举_词性 词性值) {
    if (!词节点 || !词节点->子) return nullptr;

    节点类* 当前节点 = 词节点->子;
    节点类* 起点 = 当前节点;

    do {
        // 检查当前节点的主信息是否为词性主信息类
        if (auto* 词性信息 = dynamic_cast<词性主信息类*>(当前节点->主信息)) {
            if (词性信息->词性 == 词性值) {
                return static_cast<词节点类*>(当前节点);
            }
        }

        当前节点 = 当前节点->下;
        if (!当前节点 || 当前节点 == 词节点->子) break; // 防止循环或破链

    } while (当前节点 != 起点);

    return nullptr;
    
 }
词节点类* 语素类::查找词性节点(节点类* 词节点, std::string 词性值)
{
    枚举_词性 词性 = 枚举_词性_工厂::根据文本获取枚举值(词性值);
    return 查找词性节点(词节点, 词性);
}
词节点类* 语素类::查找词性节点(结构体_分词 分词信息)
{
    词节点类* 词节点 = 添加词(分词信息.词);
    return 查找词性节点(词节点, 分词信息.词性);
}

词节点类* 语素类::获取词性词指针(const std::string& 词字符串)
{
    return 查找词(词字符串);
}
 

 // 在词节点中添加一个词性子节点
词节点类* 语素类::添加词性词(词节点类* 词节点, 枚举_词性 词性) {
     if (!词节点) {
         throw std::invalid_argument("添加词性词(词节点, 词性词) 时, 词节点 或 词性词 为空值!");
     }
     if (词性 == 枚举_词性::未定义) {
         std::string 参数 = "添加词性词(词节点, 词性词) 时,  词性 未定义 !" +枚举_词性_工厂::根据枚举类型获取文本(词性);
         throw std::invalid_argument(参数);
     }
     词性节点类* 词性节点= 查找词性节点(词节点, 词性);
     if (词性节点 != nullptr) return 词性节点;
     词性主信息类* 词性主信息 = new 词性主信息类(词性);
     词性节点 = new 词性节点类();
     词性节点->主信息 = 词性主信息;
     return  添加子节点(词节点, 词性节点);

     
 }


词节点类* 语素类::添加词性词(std::string 词值, std::string 词性值) {
    词节点类* 词指针 = 添加词(词值);
    枚举_词性 词性 = 枚举_词性_工厂::根据文本获取枚举值(词性值);
    return 添加词性词(词指针,词性); // 直接返回现有节点
}

词节点类* 语素类::添加词性词(结构体_分词 词信息) { return 添加词性词(词信息.词, 词信息.词性); }

词性节点类* 语素类::绑定词性词到场景基础信息(const std::string& 词字符串, 枚举_词性 词性, 场景节点类* 场景, 基础信息节点类* 基础信息节点)
{
    if (词字符串.empty() || !基础信息节点 || !场景) {
        throw std::invalid_argument("绑定词性词到场景基础信息: 词/基础信息/场景 为空!");
    }
    if (词性 == 枚举_词性::未定义) {
        throw std::invalid_argument("绑定词性词到场景基础信息: 词性未定义!");
    }

    // 1. 先获取 / 创建词节点
    词节点类* 词节点 = 添加词(词字符串);

    // 2. 再获取 / 创建词性节点
    词性节点类* 词性节点 = 查找词性节点(词节点, 词性);
    if (!词性节点) {
        词性节点 = 添加词性词(词节点, 词性); // 这里只建语素结构
    }

    // 3. 绑定到词性主信息中的“场景示例列表”
    auto* 主信息 = dynamic_cast<词性主信息类*>(词性节点->主信息);
    if (!主信息) {
        throw std::invalid_argument("绑定词性词到场景基础信息: 词性节点主信息类型错误!");
    }

    主信息->添加场景示例(场景, 基础信息节点);

    return 词性节点;
}

词节点类* 语素类::添加二次特征词(语素节点类* 参照物, 语素节点类* 比较对象, 语素节点类* 比较类型) { return nullptr; }
 int64_t 语素类::添加对应基础信息(词性节点类* 词节点, 基础信息节点类* 基础信息) {
     if (!词节点) throw std::invalid_argument("词节点不能为空");
     if (!基础信息)  throw std::invalid_argument("基础信息不能为空");
     auto* 词性主信息 = dynamic_cast<词性主信息类*>(词节点->主信息);
     if (!词性主信息)  throw std::runtime_error("词节点的主信息不是词性主信息类类型");
     词性主信息->对应基础信息指针 = 基础信息;
     return 1; // 成功
 }
 std::string 语素类::获取词(词性节点类* 词性词指针) {
     if (!词性词指针) {
         throw std::invalid_argument("获取词：词性词指针为空！");
     }
     if (!词性词指针->父) {
         throw std::invalid_argument("获取词：词性词指针没有父节点（词信息节点）！");
     }
     if (!词性词指针->父->主信息) {
         throw std::invalid_argument("获取词：词信息节点的主信息为空！");
     }
     auto* 词主信息 = dynamic_cast<词主信息类*>(词性词指针->父->主信息);
     if (!词主信息) {
         throw std::invalid_argument("获取词：父节点主信息不是词主信息类！");
     }
     return 词主信息->词;
 }

 // 纯查找：存在则返回节点，不存在返回 nullptr（不会创建）
 词节点类* 语素类::查找词(const std::string& 词字符串) {
     if (词字符串.empty()) return nullptr;

     词节点类* 当前游标 = 根指针;
     std::string 前缀;

     for (char ch : 词字符串) {
         前缀 += ch;
         词主信息类 临时(前缀);

         auto* 节点 = (当前游标 == 根指针)
             ? 查找节点_当前链(当前游标, &临时, 枚举_比较字段::语素_词_词, 枚举_比较条件::相等)
             : 查找节点_当前链(当前游标->子, &临时, 枚举_比较字段::语素_词_词, 枚举_比较条件::相等);

         if (!节点) return nullptr;
         当前游标 = 节点;
     }
     return 当前游标;
 } 

 枚举_主信息类型 语素类::映射_词性到主信息类型(枚举_词性 词性) {
     switch (词性) {
         // 原有映射规则
     case 枚举_词性::n:
     case 枚举_词性::名词:
     case 枚举_词性::专有名词:
     case 枚举_词性::nr:    // 人名
     case 枚举_词性::PER:   // 人名
     case 枚举_词性::ns:    // 地名
     case 枚举_词性::LOC:   // 地名
     case 枚举_词性::nt:    // 机构团体名
     case 枚举_词性::ORG:   // 机构名
     case 枚举_词性::nw:    // 作品名
     case 枚举_词性::nz:    // 其他专名
         return 枚举_主信息类型::存在信息;

     case 枚举_词性::代词:
     case 枚举_词性::r:     // 代词
         return 枚举_主信息类型::存在信息_指代;

     case 枚举_词性::动词:
     case 枚举_词性::v:     // 普通动词
     case 枚举_词性::vd:    // 动副词
     case 枚举_词性::vn:    // 名动词
         return 枚举_主信息类型::动态信息;

     case 枚举_词性::形容词:
     case 枚举_词性::a:     // 形容词
     case 枚举_词性::ad:    // 副形词
     case 枚举_词性::an:    // 名形词
         return 枚举_主信息类型::特征信息;

     case 枚举_词性::副词:
     case 枚举_词性::d:     // 副词
         return 枚举_主信息类型::二次特征_修饰;

     case 枚举_词性::数词:
     case 枚举_词性::量词:
     case 枚举_词性::m:     // 数量词
     case 枚举_词性::q:     // 量词
         return 枚举_主信息类型::特征信息_数量;

     case 枚举_词性::介词:
     case 枚举_词性::连词:
     case 枚举_词性::p:     // 介词
     case 枚举_词性::c:     // 连词
     case 枚举_词性::u:     // 助词
     case 枚举_词性::xc:    // 其他虚词
         return 枚举_主信息类型::关系信息;

         // 新增时间类映射
     case 枚举_词性::时间词:
     case 枚举_词性::t:     // 时间名词
     case 枚举_词性::TIME:  // 时间
         return 枚举_主信息类型::动态信息;  // 时间词通常与动作/状态的时间属性相关

         // 其他未明确分类的词性
     default:
         return 枚举_主信息类型::语言信息_仅记录;
     }
 }

 // 静态成员变量定义
 const std::unordered_map<std::string, 枚举_词性> 枚举_词性_工厂::文本到枚举映射表 = {
     // 中文全称映射
     {"名词", 枚举_词性::名词},
     {"动词", 枚举_词性::动词},
     {"形容词", 枚举_词性::形容词},
     {"副词", 枚举_词性::副词},
     {"连词", 枚举_词性::连词},
     {"介词", 枚举_词性::介词},
     {"专有名词", 枚举_词性::专有名词},
     {"抽象名词", 枚举_词性::抽象名词},
     {"代词", 枚举_词性::代词},
     {"数词", 枚举_词性::数词},
     {"量词", 枚举_词性::量词},
     {"助词", 枚举_词性::助词},
     {"叹词", 枚举_词性::叹词},
     {"拟声词", 枚举_词性::拟声词},
     {"标点符号", 枚举_词性::标点符号},
     {"时间词", 枚举_词性::时间词},
     {"状态词", 枚举_词性::状态词},
     {"方位词", 枚举_词性::方位词},
     {"习用语", 枚举_词性::习用语},
     {"简称略语", 枚举_词性::简称略语},
     {"非语素字", 枚举_词性::非语素字},
     {"语气词", 枚举_词性::语气词},
     {"外文字符", 枚举_词性::外文字符},
     {"未定义", 枚举_词性::未定义},
     {"地名", 枚举_词性::地名},

     // 字母缩写映射（指向统一的中文概念）
     {"n", 枚举_词性::名词},
     {"f", 枚举_词性::方位词},
     {"s", 枚举_词性::地名},
     {"t", 枚举_词性::时间词},
     {"nr", 枚举_词性::专有名词},
     {"ns", 枚举_词性::地名},
     {"nt", 枚举_词性::专有名词},
     {"nw", 枚举_词性::专有名词},
     {"nz", 枚举_词性::专有名词},
     {"v", 枚举_词性::动词},
     {"vd", 枚举_词性::副词},
     {"vn", 枚举_词性::动词},
     {"a", 枚举_词性::形容词},
     {"ad", 枚举_词性::副词},
     {"an", 枚举_词性::形容词},
     {"d", 枚举_词性::副词},
     {"m", 枚举_词性::数词},
     {"q", 枚举_词性::量词},
     {"r", 枚举_词性::代词},
     {"p", 枚举_词性::介词},
     {"c", 枚举_词性::连词},
     {"u", 枚举_词性::助词},
     {"xc", 枚举_词性::未定义},
     {"w", 枚举_词性::标点符号},

     // 专名识别缩略词映射
     {"PER", 枚举_词性::专有名词},
     {"LOC", 枚举_词性::地名},
     {"ORG", 枚举_词性::专有名词},
     {"TIME", 枚举_词性::时间词}
 };

 // 动态映射表初始化
 std::unordered_map<枚举_词性, std::string> 枚举_词性_工厂::枚举到文本动态映射表 = {
     // 可以在这里预置一些动态映射，或保持为空
     // 原有枚举项映射
        {枚举_词性::名词, "名词"},
        {枚举_词性::动词, "动词"},
        {枚举_词性::形容词, "形容词"},
        {枚举_词性::副词, "副词"},
        {枚举_词性::连词, "连词"},
        {枚举_词性::介词, "介词"},
        {枚举_词性::专有名词, "专有名词"},
        {枚举_词性::抽象名词, "抽象名词"},
        {枚举_词性::代词, "代词"},
        {枚举_词性::数词, "数词"},
        {枚举_词性::量词, "量词"},
        {枚举_词性::助词, "助词"},
        {枚举_词性::叹词, "叹词"},
        {枚举_词性::拟声词, "拟声词"},
        {枚举_词性::标点符号, "标点符号"},
        {枚举_词性::时间词, "时间词"},
        {枚举_词性::状态词, "状态词"},
        {枚举_词性::方位词, "方位词"},
        {枚举_词性::习用语, "习用语"},
        {枚举_词性::简称略语, "简称略语"},
        {枚举_词性::非语素字, "非语素字"},
        {枚举_词性::语气词, "语气词"},
        {枚举_词性::外文字符, "外文字符"},
        {枚举_词性::未定义, "未定义"},
        {枚举_词性::地名, "地名"},

        // 新增词性映射
        {枚举_词性::n, "n"},
        {枚举_词性::f, "f"},
        {枚举_词性::s, "s"},
        {枚举_词性::t, "t"},
        {枚举_词性::nr, "nr"},
        {枚举_词性::ns, "ns"},
        {枚举_词性::nt, "nt"},
        {枚举_词性::nw, "nw"},
        {枚举_词性::nz, "nz"},
        {枚举_词性::v, "v"},
        {枚举_词性::vd, "vd"},
        {枚举_词性::vn, "vn"},
        {枚举_词性::a, "a"},
        {枚举_词性::ad, "ad"},
        {枚举_词性::an, "an"},
        {枚举_词性::d, "d"},
        {枚举_词性::m, "m"},
        {枚举_词性::q, "q"},
        {枚举_词性::r, "r"},
        {枚举_词性::p, "p"},
        {枚举_词性::c, "c"},
        {枚举_词性::u, "u"},
        {枚举_词性::xc, "xc"},
        {枚举_词性::w, "w"},

        // 专名识别缩略词映射
        {枚举_词性::PER, "PER"},
        {枚举_词性::LOC, "LOC"},
        {枚举_词性::ORG, "ORG"},
        {枚举_词性::TIME, "TIME"}
 };
