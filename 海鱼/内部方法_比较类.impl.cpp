module 内部方法_比较模块;

import 世界树模块;
import 特征值模块;     // 为了用 计算矢量相似度 等工具
import 主信息定义模块; // 包含 枚举_特征类型 / 节点类 / 二次特征主信息基类 等


基础信息节点类* 内部方法_比较类::比较存在(基础信息节点类* 存在A, 基础信息节点类* 存在B,世界树类& 世界树)
{
    if (!存在A || !存在B) return nullptr;

    // 1. 创建“存在比较”的二次特征主信息
    auto* 主信息 = new 二次特征主信息类(
        枚举_二次特征种类::存在比较,
        枚举_比较结果::未定义,  // 综合结果先留空
        存在A,
        存在B
    );

    // 2. 创建一个新节点，挂到世界树合适的地方
    基础信息节点类* 二次特征节点 = 世界树.创建节点(主信息); // 具体函数名按你的世界树类来
    // 也可以先不挂树，只构造一颗“二次特征子树”返回给上层

    // 3. 收集两个存在的特征子节点，并按“特征类型”分组
    std::map<枚举_特征类型, std::vector<基础信息节点类*>> A特征分组;
    std::map<枚举_特征类型, std::vector<基础信息节点类*>> B特征分组;

    auto 收集特征 = [](节点类* 存在节点,
        std::map<枚举_特征类型, std::vector<基础信息节点类*>>& 目标分组)
        {
            if (!存在节点 || !存在节点->子) return;

            基础信息节点类* 游标 = 存在节点->子;
            do {
                if (游标->主信息 && 游标->主信息->类型 == 枚举_主信息类型::特征) {
                    auto* 特征主信息 = dynamic_cast<特征主信息类*>(游标->主信息);
                    if (特征主信息) {
                        目标分组[特征主信息->特征类型].push_back(游标);
                    }
                }
                游标 = 游标->下;
            } while (游标 != 存在节点->子);
        };

    收集特征(存在A, A特征分组);
    收集特征(存在B, B特征分组);

    // 4. 对“所有出现过的特征类型”做一遍比较
    std::map<枚举_特征类型, bool> 已处理类型; // 防止重复
    auto 处理类型 = [&](枚举_特征类型 类型)
        {
            const auto& 列表A = A特征分组[类型];
            const auto& 列表B = B特征分组[类型];

            if (列表A.empty() && 列表B.empty()) return;

            比较特征类型子链(
                二次特征节点,
                列表A,
                列表B,
                类型,
                世界树
            );
        };

    for (auto& [类型, _] : A特征分组) {
        处理类型(类型);
        已处理类型[类型] = true;
    }
    for (auto& [类型, _] : B特征分组) {
        if (!已处理类型[类型])
            处理类型(类型);
    }

    // 5. 可以根据所有子节点的结果，综合出“存在层面”的结果（比如相似度平均等）
    // TODO: 综合逻辑先留给你，以后可以按权重计算

    return 二次特征节点;
}

基础信息节点类* 内部方法_比较类::比较特征类型子链(
    基础信息节点类* 父二次特征节点,
    const std::vector<基础信息节点类*>& 特征A列表,
    const std::vector<基础信息节点类*>& 特征B列表,
    枚举_特征类型 特征类型,
    世界树类& 世界树)
{
    if (!父二次特征节点) return nullptr;

    // 创建一个“特征类型层”的二次特征节点
    auto* 主信息 = new 二次特征主信息类(
        枚举_二次特征种类::特征比较,
        枚举_比较结果::未定义,
        特征A列表.empty() ? nullptr : 特征A列表.front()->父,
        特征B列表.empty() ? nullptr : 特征B列表.front()->父
    );

    auto* 特征类型二次节点 = 世界树.创建节点(主信息);
    世界树.添加子节点(父二次特征节点, 特征类型二次节点);

    // 一一配对比较
    size_t n = std::max(特征A列表.size(), 特征B列表.size());
    for (size_t i = 0; i < n; ++i)
    {
        节点类* 节点A = (i < 特征A列表.size()) ? 特征A列表[i] : nullptr;
        节点类* 节点B = (i < 特征B列表.size()) ? 特征B列表[i] : nullptr;

        if (!节点A && !节点B) continue;

        节点类* 单个比较节点 = 比较单个特征(
            特征类型二次节点,
            节点A,
            节点B,
            特征类型,
            世界树
        );

        if (单个比较节点) {
            世界树.添加子节点(特征类型二次节点, 单个比较节点);
        }
    }

    return 特征类型二次节点;
}

基础信息节点类* 内部方法_比较类::比较单个特征(
    基础信息节点类* 父二次特征节点,
    基础信息节点类* 特征A,
    基础信息节点类* 特征B,
    枚举_特征类型 特征类型,
    世界树类& 世界树)
{
    // 任意一边不存在：可以记一个“缺失”的二次特征
    if (!特征A || !特征B) {
        auto* 主 = new 二次特征主信息基类(
            枚举_二次特征种类::特征比较,
            枚举_比较结果::无法比较,
            特征A,
            特征B
        );
        return 世界树.创建节点(主);
    }

    auto* 特征信息A = dynamic_cast<特征主信息类*>(特征A->主信息);
    auto* 特征信息B = dynamic_cast<特征主信息类*>(特征B->主信息);
    if (!特征信息A || !特征信息B) return nullptr;

    // 根据特征值类型决定比较方式：
    //   1. 标量：作差、比较大小
    //   2. 矢量：用 特征值类::计算矢量相似度
    //   3. 字符串：看是否相等 / 编辑距离（以后再扩展）
    枚举_比较结果 结果 = 枚举_比较结果::无法比较;
    double 差值 = 0.0;
    double 相似度 = 0.0;

    if (auto* 标量A = dynamic_cast<标量特征值主信息类*>(特征信息A->值);
        标量A && 特征信息B->值)
    {
        if (auto* 标量B = dynamic_cast<标量特征值主信息类*>(特征信息B->值)) {
            // 标量比较
            差值 = static_cast<double>(标量A->值) - static_cast<double>(标量B->值);
            if (差值 < 0)      结果 = 枚举_比较结果::小于;
            else if (差值 > 0) 结果 = 枚举_比较结果::大于;
            else               结果 = 枚举_比较结果::等于;
        }
    }
    else if (auto* 矢量A = dynamic_cast<矢量特征值主信息类*>(特征信息A->值);
        矢量A && 特征信息B->值)
    {
        if (auto* 矢量B = dynamic_cast<矢量特征值主信息类*>(特征信息B->值)) {
            // 矢量相似度（用你刚刚实现的工具函数）
            相似度 = 特征值类::计算矢量相似度(矢量A->值, 矢量B->值);
            if (相似度 >= 0.99)      结果 = 枚举_比较结果::等于;
            else if (相似度 >= 0.8)  结果 = 枚举_比较结果::大于;   // “比较相似”
            else                     结果 = 枚举_比较结果::小于;   // “差异较大”
        }
    }
    else if (auto* 字符A = dynamic_cast<字符特征值主信息类*>(特征信息A->值);
        字符A && 特征信息B->值)
    {
        if (auto* 字符B = dynamic_cast<字符特征值主信息类*>(特征信息B->值)) {
            // 字符串简单比较（是否相等）
            if (字符A->值 == 字符B->值)
                结果 = 枚举_比较结果::等于;
            else
                结果 = 枚举_比较结果::无法比较; // 或者你想要“不同”也可以定义一个枚举
        }
    }

    auto* 主 = new 二次特征主信息类(
        枚举_二次特征种类::特征比较,
        结果,
        特征A,
        特征B,
        差值,
        相似度
    );
    return 世界树.创建节点(主);
}
