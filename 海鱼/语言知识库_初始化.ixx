export module 语言知识库_初始化;

import <string>;
import <vector>;
import <unordered_map>;
//import 语言知识库模块;          // 上条消息提供的模块
import 主信息定义模块;      // 你现有的类型与工厂
// 可选：import 模板模块 / 基础数据类型模块，视你的工程组织

// —— 工具：取/建 词性词（根据你的词典实现替换） ——
static 词性节点类* _取词(const std::string& 面, 枚举_词性 词性) {
    // TODO: 这里调用你已有的“查找/创建词性词”接口
    // 占位返回空指针以便你替换
    return nullptr;
}

// —— 线性化策略：SVO（主语→谓词→宾语），状语（时间/地点）可选后置 ——
static std::vector<词性节点类*> _线性化_SVO(
    const 结构体_语言模板& 模板,
    const 结构体_线性化上下文& ctx)
{
    std::vector<词性节点类*> 序列;
    // 模板.词序列槽位中，约定：索引语义依次为 主语, 谓词, 宾语, 时间?, 地点?
    for (词性节点类* slot : 模板.词序列槽位) {
        if (slot) 序列.push_back(slot);
    }
    return 序列;
}

// —— 线性化策略：比较结构（E1 比 E2 更 形容词 [参照]） ——
static std::vector<词性节点类*> _线性化_比较(
    const 结构体_语言模板& 模板,
    const 结构体_线性化上下文& ctx)
{
    std::vector<词性节点类*> 序列;
    // 词序列槽位约定：E1名, “比”, E2名, “更/最/稍”, 形容词, 参照?
    for (auto* slot : 模板.词序列槽位) {
        if (slot) 序列.push_back(slot);
    }
    return 序列;
}

// —— 构造条目便捷函数 ——
static 结构体_语言知识条目 _条目(
    枚举_LK用途 用途, const std::string& 模板ID,
    const std::vector<词性节点类*>& 槽位,
    const std::string& 线性化策略ID,
    const std::vector<int>& 必备约束 = {},
    const std::vector<int>& 触发条件 = {},
    const std::vector<int>& 二次特征配方 = {},
    bool 输出为短语 = true)
{
    结构体_语言知识条目 t{};
    t.语言.用途 = 用途;
    t.语言.模板ID = 模板ID;
    t.语言.词序列槽位 = 槽位;
    t.语言.线性化策略ID = 线性化策略ID;
    t.场景模板.必备约束ID = 必备约束;
    t.触发条件ID = 触发条件;
    t.二次特征配方ID = 二次特征配方;
    t.输出为短语 = 输出为短语;
    return t;
}

// —— 注册六类基础模板（示例词使用占位函数 _取词，你可替换为词典指针） ——
static void _注册_存在_陈述() {
    // 模板： [E1名] [在] [地点名]?    —— 线性化：SVO 的无宾语/地点状语变体
    auto* w在 = _取词("在", 枚举_词性::介词);
    // 槽位中按顺序放：E1名、在、地点名（若无地点名则仅输出 E1名）
    std::vector<词性节点类*> 槽位 = { /*E1名*/nullptr, w在, /*地点名*/nullptr };
    auto item = _条目(枚举_LK用途::存在_陈述, "模板_存在_在地点",
        槽位, "线性化_SVO");
  //  语言知识库类::注册_LK条目(item);
}

static void _注册_特征_描述() {
    // 模板： [E1名] [的] [Fx名/值]    —— 特征后置
    auto* w的 = _取词("的", 枚举_词性::助词);
    std::vector<词性节点类*> 槽位 = { /*E1名*/nullptr, w的, /*Fx名/值*/nullptr };
    auto item = _条目(枚举_LK用途::特征_描述, "模板_特征_名的特征",
        槽位, "线性化_SVO");
  //  语言知识库类::注册_LK条目(item);
}

static void _注册_事件_叙述() {
    // 模板： [E1名] [动词] [E2名]? [在] [地点]? [于] [时间]?
    auto* 在 = _取词("在", 枚举_词性::介词);
    auto* 于 = _取词("于", 枚举_词性::介词);
    // 槽位粗略示意：E1, 动词, E2, 在, 地点, 于, 时间
    std::vector<词性节点类*> 槽位 = { nullptr, /*动词*/nullptr, nullptr, 在, nullptr, 于, nullptr };
    auto item = _条目(枚举_LK用途::事件_叙述, "模板_事件_SVO_状语",
        槽位, "线性化_SVO");
  //  语言知识库.注册_LK条目(item);
}

static void _注册_关系_布局() {
    // 模板： [E1名] [在] [E2名] [左/右/上/下/内/外…]   —— 方位短语
    auto* 在 = _取词("在", 枚举_词性::介词);
    std::vector<词性节点类*> 槽位 = { nullptr, 在, nullptr, /*方位词*/nullptr };
    auto item = _条目(枚举_LK用途::关系_布局, "模板_关系_方位",
        槽位, "线性化_SVO");
   // 语言知识库类::注册_LK条目(item);
}

static void _注册_比较_排序() {
    // 模板： [E1名] [比] [E2名] [更] [形容词] [参照]? —— 比较结构
    auto* 比 = _取词("比", 枚举_词性::介词);
    auto* 更 = _取词("更", 枚举_词性::副词);
    std::vector<词性节点类*> 槽位 = { nullptr, 比, nullptr, 更, /*形容词*/nullptr, /*参照*/nullptr };
    // 绑定二次特征配方ID（示例写 101：Δ/排序；实际用你的枚举/注册值）
    auto item = _条目(枚举_LK用途::比较_排序, "模板_比较_E1比E2更Adj",
        槽位, "线性化_比较",
        /*必备约束*/{}, /*触发*/{}, /*二次特征配方*/{ 101 });
  //  语言知识库类::注册_LK条目(item);
}

static void _注册_因果_解释() {
    // 模板： [因为] [子句A] [所以] [子句B]  —— 两子句拼接
    auto* 因为 = _取词("因为", 枚举_词性::连词);
    auto* 所以 = _取词("所以", 枚举_词性::连词);
    std::vector<词性节点类*> 槽位 = { 因为, /*子句A*/nullptr, 所以, /*子句B*/nullptr };
    auto item = _条目(枚举_LK用途::因果_解释, "模板_因果_因为所以",
        槽位, "线性化_SVO");
  //  语言知识库类::注册_LK条目(item);
}

// —— 对外初始化：注册线性化策略 + 六类模板 ——
export void 初始化_语言知识库_默认() {
    // 1) 线性化策略
  //  语言知识库类::注册_线性化策略("线性化_SVO", _线性化_SVO);
 //   语言知识库类::注册_线性化策略("线性化_比较", _线性化_比较);

    // 2) 基础模板
    _注册_存在_陈述();
    _注册_特征_描述();
    _注册_事件_叙述();
    _注册_关系_布局();
    _注册_比较_排序();
    _注册_因果_解释();
}
