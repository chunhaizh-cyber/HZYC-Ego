export module 二次特征模块;
import<cassert>;
import <vector>;
import <string>;
import <cstdint>;  // for int64_t
import <chrono>;   // for steady_clock
import <functional>;

import 主信息定义模块;
import 模板模块;
import 基础数据类型模块;
import 主信息定义模块;

import 世界树模块;
import 状态模块;
import 动态模块;
import 语素模块;


export class 二次特征树类 :public 链表模板<基础信息基类*>{    

public:
    // 世界树变动时调用：自动生成二次特征节点
//   二次特征节点类* 生成比较特征(存在节点类* A,存在节点类* B,词性节点类* 维度)
//   {
//       // 1. 基础空指针检查
//       if (!A || !B || !维度) {
//           return nullptr;
//       }
//
//       // 2. 提取存在主信息
//       auto* A信息 = dynamic_cast<存在节点主信息类*>(A->主信息);
//       auto* B信息 = dynamic_cast<存在节点主信息类*>(B->主信息);
//       if (!A信息 || !B信息) {
//           // 说明主信息类型不是存在节点主信息类，直接放弃
//           return nullptr;
//       }
//
//       // 3. 按维度获取当前特征
//       特征节点类* 特征A = A信息->获取当前特征(维度);
//       特征节点类* 特征B = B信息->获取当前特征(维度);
//       if (!特征A || !特征B) {
//           return nullptr;
//       }
//
//       // 4. 从特征节点里取出“特征值主信息”
//       //    这里的类型名请改成你实际定义的类型，比如：
//       //    - 特征值基类
//       //    - 矢量特征值节点主信息类 / 非矢量特征值节点主信息类 的共同基类
//       auto* A值主信息 = dynamic_cast<特征值基类*>(特征A->主信息);
//       auto* B值主信息 = dynamic_cast<特征值基类*>(特征B->主信息);
//       if (!A值主信息 || !B值主信息) {
//           // 这个维度上不是“可比较的特征值”，直接放弃
//           return nullptr;
//       }
//
//       // 5. 执行特征值比较
//       //    假设 特征值主信息基类::比较(...) 的签名类似：
//       //    std::int64_t 比较(特征值主信息基类* 对象, 枚举_比较字段 字段, 枚举_比较条件 条件) const;
//       std::int64_t 比较结果 = A值主信息->比较(
//           B值主信息,
//           枚举_比较字段::基础信息_矢量特征值_值,
//           枚举_比较条件::大于
//       );
//
//       // 1. 以“主信息类型”定义一个变量（主信息类型一般是 主信息基类*）
//       auto* 二信息变量 = new 二次特征主信息类(A, B, 比较结果, 维度);
//       return 添加节点(二信息变量);       
//
//   }


    // 查询最强的二次特征（用于生成语言）
   
};


